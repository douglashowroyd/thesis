\chapter{Parallel method for a congruence by generating pairs}
\label{chap:pairs}

A congruence is a binary relation, and is therefore formally described as a set
of pairs.  In a computational setting, it is rarely practical to keep track of
every pair in a congruence; a congruence on a semigroup of size $n$ contains
$n^2$ pairs in the worst case, and on an infinite semigroup contains an infinite
number of pairs.  A congruence can be described in more concise ways utilising
known theory: for example, taking advantage of its being an equivalence relation
and recording only its equivalence classes; or in the case of a Rees congruence,
storing a generating set for the ideal which defines it.  A variety of different
ways to describe a congruence are explained in Chapter \ref{chap:converting},
along with ways to convert one to another.  However, a congruence is still just
a set of pairs, and by reducing the number of pairs we store, we can describe a
congruence very concisely using them.

A congruence $\rho$ is \textit{generated by} a set of pairs $R$ if it consists
of only the pairs in $R$ along with the pairs required by the axioms of a
congruence (reflexivity, symmetry, transitivity and compatibility).  Thus a
congruence can be described completely by storing only a few pairs.
Indeed, experiments on a range of interesting semigroups in Chapter
\ref{chap:lattice} show that many congruences can be generated by an extremely
small number of generating pairs, and indeed that most of the congruences
studied are principal (generated by a single pair). %TODO: actually do this

Another justification for the use of generating pairs is that it is a completely
generic representation.  Some special types of semigroup have their own abstract
representations of congruences---for inverse semigroups, one can study
kernel-trace pairs; for groups, normal subgroups; for completely simple or
completely 0-simple semigroups, linked triples---but generating pairs can
represent a congruence on any semigroup whatsoever.  Furthermore, a researcher
might be interested in what pairs are implied by a given pair or set of pairs in
a congruence, and this representation can answer such questions.

Left congruences and right congruences can also be described using generating
pairs, and some algorithms designed for two-sided congruences can be used with
minor modifications to compute information about left and right congruences.

This chapter describes a parallelised approach for computing a congruence from a
set of generating pairs, as implemented in \texttt{libsemigroups}
\cite{libsemigroups}.  First we will give a general outline of the system
and what questions it hopes to answer, then we will describe in detail each
algorithms used, its advantages and disadvantages, and when it can be applied.
Finally we will explain how the different algorithms are executed together, and
consider their implementation in \cite{libsemigroups}.

\section{Parallelisation}

Parallel processing has seen major advances in the last ten years, with
multi-core processors becoming the norm in many types of computers, and
processors with 4, 8, or even 16 cores becoming common on a desktop PC.  This
being the case, it is desirable to parallelise mathematical algorithms wherever
possible, and take advantage of the ability to execute multiple
threads of instructions concurrently.  Some algorithms, such as simple binary
searches, are ``embarrassingly parallel''---that is, they can be split into
independent threads which require almost no communication with each other.
These are suited so well to parallelisation that splitting the operation into
$n$ parallel threads reduces the expected run-time to barely more than
$\frac{1}{n}$ what it would be when run in a single thread.  Other
algorithms do not parallelise so well: sometimes threads have to communicate, or
use shared resources, causing significant slowdown and severely limiting the
improvements which can be made by parallelising.

When it comes to computing information about a congruence from generating pairs,
there are various different approaches which can be taken: in Sections
\ref{sec:tc}, \ref{sec:kbfp} and \ref{sec:p}, we describe three
possible algorithms.  Depending on what sort of semigroup is described, several
or all of these might be appropriate.  However, depending on certain properties
of the congruence, one might perform far better than another.  For example, the
pair orbit algorithm works well on congruences which contain few non-reflexive
pairs, while the Todd-Coxeter algorithm tends to work well on congruences with
few classes (i.e.~very many pairs).  Given only a set of generating pairs, these
properties may be unknown in advance, which makes it difficult to choose a good
algorithm.

The natural answer to this problem is the core concept of this chapter: a
parallel approach which does not attempt to parallelise individual algorithms,
but which runs all known algorithms at the same time, each in a different
thread, and simply halts all threads as soon as any one completes.  Since these
algorithms do not interact with each other in any way, the total run-time will
be close to the minimum run-time of all the different algorithms.  This is
particularly important, since some of the algorithms never terminate for certain
semigroups and congruences (for example, those of infinite size).

\section{Parameters}

We need to know what sorts of semigroups and congruences we are considering, as
well as what information we want to extract from them.

\subsection{Types of semigroup}

The type of element in a semigroup affects which methods will be most effective,
or even which methods will be applicable.  For this purpose, we divide
semigroups into two categories: finitely presented semigroups, and
\textit{concrete} semigroups.  By \textit{concrete}, we mean a finite semigroup
whose elements can be multiplied and compared quickly, without reference to the
semigroup as a whole; these could be semigroups of transformations, partial
permutations, bipartitions, matrices, or other finite objects.  Their elements
will be known in advance.  Finitely presented semigroups are a different case,
in that their elements are not known in advance, and indeed it may not be known
whether or not they are finite.  Finitely presented monoids are treated as
equivalent to finitely presented semigroups, since a semigroup presentation can
be attained by simply adding a generator for the identity and relations to make
it multiplicatively neutral.

\subsection{Questions}

Each method we are about to explain can provide a variety of information, but it
is important to consider which questions we aim to answer.  Our system should be
able to return the following information about a given congruence when
requested:

\begin{itemize}
\item Presence of a given pair $(x,y)$
\item Number of congruence classes
\item The elements in each non-trivial congruence class
\item Class number of a given element
\end{itemize}

Note that for finitely presented semigroups, these questions may be
undecidable.  In the case that a question is decidable, our approach should
return an answer in finite time.

\section{Todd-Coxeter}
\label{sec:tc}

The Todd-Coxeter algorithm, as originally described in 1936 in
\cite{todd-coxeter}, was an algorithm to enumerate the cosets of a finitely
generated subgroup of a finitely presented group.  Arriving before the advent of
electronic computers, it was originally carried out by hand.

The TC algorithm

Pre-filling the table

Semigroups/congs it works/works best on

Complexity

\section{KBFP}
\label{sec:kbfp}

Background

The KBFP algorithm

Semigroups/congs it works/works best on

Complexity

\section{Pair orbit enumeration}
\label{sec:p}

Background

The P algorithm

Using Knuth-Bendix: KBP

Semigroups/congs it works/works best on

Complexity

\section{Running in parallel}

How do we tie together all the different algorithms?

\section{Implementation}

Practical considerations in libsemigroups

Showing off speed

Drawbacks
