\chapter{Converting between representations}
\label{chap:converting}

A congruence is a binary relation, and therefore is formally described as a set
of pairs -- a subset of $S \times S$.  In both computational and mathematical
settings, it is worth thinking about how a congruence could be stored.

One approach to storing a congruence $\rho$ on a semigroup $S$ is simply to
store every one of its pairs.  In principle, it is possible to store
$\rho$ in this way if and only if $S$ is finite.  However, this could well use a
lot of storage -- even the trivial congruence would use $O(|S|)$ space, and in
general a congruence could even use $O(|S|^2)$ space.

% TODO? quantify that we need very few pairs
In Chapter \ref{chap:pairs} we looked in detail at how a congruence can be
represented by a set of generating pairs.  As we found there, a congruence can
be described by a subset $\R \subseteq \rho$, which in many cases can be
very small.  This is one very generic way of representing congruences, in two
senses: firstly that it can be used for any finite semigroup; and secondly that
it can be used for left and right congruences.

However, there are other ways to view congruences in certain circumstances: some
semigroups have properties such as being an inverse semigroup or being a group,
which allow additional things to be said about their congruences; and some
specific congruences have special properties, such as being Rees, which allows
them to be represented in a certain way.  In this chapter, we will describe some
important ways of representing congruences, and then consider ways of converting
one to another.  Section numbers for the different representations and the ways
they can be converted to one another are summarised in Table
\ref{tab:converting}.

\begin{table}[ht]
  \centering
  \renewcommand{\arraystretch}{1.3}
  \begin{tabular}{ r | r | c | c | c | c | c |}
    \multicolumn{7}{c}{\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad \ldots to \ldots} \\
    \cline{2-7}
    \multirow{7}{*}{\rotatebox[origin=c]{90}{From\ldots}} &  & GP & NS & LT & KT & RC \\
    \cline{2-7}
    & Generating pairs ~\ref{sec:converting-pairs} & \cellcolor{black} & \ref{sec:trivial-conversions} & \ref{sec:pairs-to-linked-triple} & \ref{sec:pairs-to-kertr} & \textcolor{gray!50}{\ref{sec:pairs-to-rees}} \\
    \cline{2-7}
    & Normal subgroup (groups) ~\ref{sec:normal-subgroups} & \ref{sec:trivial-conversions} & \cellcolor{black} & \ref{sec:normal-subgroup-to-linked-triple} & \ref{sec:trivial-conversions} & \ref{sec:trivial-conversions}\\
    \cline{2-7}
    & Linked triple ((0-)simple) ~\ref{sec:linked-triples} & \ref{sec:linked-triple-to-pairs} & \ref{sec:normal-subgroup-to-linked-triple} & \cellcolor{black} & \ref{sec:trivial-conversions} & \ref{sec:trivial-conversions} \\
    \cline{2-7}
    & Kernel--trace (inverse) ~\ref{sec:kertr} & \textcolor{gray!50}{\ref{sec:kertr-to-pairs}} & \ref{sec:trivial-conversions} & \ref{sec:trivial-conversions} & \cellcolor{black} & \ref{sec:rees-to-kertr} \\
    \cline{2-7}
    & Rees congruence ~\ref{sec:converting-rees} & \ref{sec:rees-to-pairs} & \ref{sec:trivial-conversions} & \ref{sec:trivial-conversions} & \ref{sec:rees-to-kertr} & \cellcolor{black}\\
    \cline{2-7}
  \end{tabular}
  \renewcommand{\arraystretch}{0.7}
  \caption[References to conversion algorithms]
  {Section references to algorithms for converting between different congruence
    representations.  Grey references represent open problems}
  \label{tab:converting}
\end{table}

\section{Ways of representing a congruence}
\label{sec:ways-of-representing}

We will begin by describing several different ways of representing a congruence.
These representations all exist in some form in \GAP{} \cite{gap} or the \Semigroups{}
package \cite{semigroups}.

\subsection{Generating pairs}
\label{sec:converting-pairs}
% TODO? Can RZMSNormalization improve this at all?
Recall that a congruence $\rho$ on a semigroup $S$ can be stored using
a subset of the pairs in $\rho$.  If $\R$ is a subset of $S \times S$,
then we can say that $\R$ \textit{generates} a congruence.  The
congruence \textit{generated by} $\R$ is defined as the least congruence
on $S$ containing all the pairs in $\R$; equivalently, it is defined as
the intersection of all congruences on $S$ containing all the pairs in
$\R$.  It is denoted by $\R^\sharp$ (see Theorem
\ref{thm:rsharp}).  We have similarly defined the left congruence generated by
$\R$ (denoted by $\R^\triangleleft$) and the right congruence
generated by $\R$ (denoted by $\R^\triangleright$).
A full explanation of how generating pairs can be used to represent congruences
is given in Section \ref{sec:intro-gen-pairs}, and an approach for computing
properties of congruences using their generating pairs is given in Chapter
\ref{chap:pairs}.

Given a set of pairs $\R$, we may wish to produce the congruence
$\R^\sharp$ and represent it using one of the other methods described in
this chapter.  It is of course possible to calculate the set of all pairs in
$\R^\sharp$ and convert that to the other representation; however, in
order to find other representations with as little work as possible, it is
desirable to use the pairs in $\R$ directly, calculating as few extra
pairs as possible -- see, for example, Sections \ref{sec:pairs-to-linked-triple}
and \ref{sec:pairs-to-kertr}.  Conversely, if we wish to convert another
representation for a congruence $\rho$ to a set of generating pairs, it is
desirable to find as small a set of pairs as possible -- see, for example,
Sections \ref{sec:rees-to-pairs} and \ref{sec:linked-triple-to-pairs}.  When
converting between generating pairs and other representations, these will be the
goals.

\subsection{Groups: normal subgroups}
\label{sec:normal-subgroups}

In group theory, it is unusual to encounter discussion of congruences.  This is
because a group's congruences are closely related to another structure -- its
normal subgroups -- and any questions we could ask about a group's congruences are
easily described using normal subgroups instead.  Recall that a subgroup $N$ of
a group $G$ is \textit{normal} if and only if $g^{-1}ng \in N$ for all $g \in G$
and $n \in N$; recall also that a \textit{coset} of $N$ is the set $Ng$ or $gN$
for some $g \in G$, and that $Ng=gN$ if $N$ is normal.  The following theorem
shows how a group's normal subgroups are in bijective correspondence with its
congruences.

\begin{theorem}
  \label{thm:normal-subgroups}
  Let $G$ be a group.  If $\rho$ is a congruence on $G$, then the $\rho$-class
  containing the identity is a normal subgroup of $G$.
  Conversely, if $N$ is a normal subgroup of $G$, then its cosets are the
  classes of a congruence on $G$.

  \begin{proof}
    First, let $\rho$ be a congruence on $G$, and let $I$ be the $\rho$-class
    containing the identity $1$.  First we show that $I$ is a subgroup: if
    $a,b \in I$ then $ab ~\rho~ 11 = 1$, so $ab \in I$.
    Furthermore, we have $(a,1) \in \rho$, so
    $(aa^{-1}, 1a^{-1}) = (1, a^{-1}) \in \rho$, so $a^{-1} \in I$, and so
    $I$ is a subgroup.  To show $I$ is normal, let $g \in G$ and $i \in I$.
    Observe that $g^{-1}ig ~\rho~ g^{-1}1g = g^{-1}g = 1$, so $g^{-1}ig \in I$,
    as required.

    To show the converse, let $N$ be a normal subgroup of $G$, and let $\nu$ be
    the equivalence on $G$ whose classes are the cosets of $N$.  If
    $(x,y), (s,t) \in \nu$, then $Nx=Ny$ and $sN=tN$.  Hence
    $Nxs=Nys=ysN=ytN=Nyt$, so we have $(xs,yt) \in \nu$, meaning that $\nu$ is
    a congruence as required.
  \end{proof}
\end{theorem}

This theorem means that any information which can be taken from a congruence can
instead be taken from a normal subgroup, and so congruences on a group need
never be studied directly.  We even have the fortunate property that the
containment of normal subgroups follows the containment of the corresponding
congruences.

It is possible to calculate the normal subgroups of a finite group relatively
quickly, using a variety of well-known algorithms.  One method for finding the
normal subgroups of a finite group is given in \cite{hulpke_1998}; this is the
method used in the most general case by \GAP{} \cite{gap}, though more specific
methods are used for certain specific categories of group.  In the case of an
infinite group, it may be impossible to find all normal subgroups -- indeed, this
problem is undecidable in general \cite[Theorem 3.17]{miller_1992} -- but the
\textsc{LowIndexSubgroups} algorithm \cite[\S 5.4]{cgt} may be used to find all
normal subgroups up to a given index, given a small modification to exclude
subgroups which are not normal \cite[\S 5.5]{cgt}.

The other structures discussed in this section represent congruences on other
categories of semigroup in a similar way.

\subsection{Completely (0-)simple semigroups: linked triples}
\label{sec:linked-triples}

There is a special way of describing a congruence on a completely simple or
completely 0-simple semigroup: using a linked triple.  We will start by
explaining the terms \textit{completely simple} and \textit{completely
  0-simple}, then we will define a semigroup's linked triples and explain how
they are related to its congruences.

\begin{definition}
  \label{def:zerosimple}
  \index{simple!semigroup}
  \index{0-simple}
  A semigroup $S$ is:
  \begin{itemize}
  \item \textbf{simple} if its only ideal is $S$;
  \item \textbf{0-simple} if it contains a zero, and has precisely two ideals.
  \end{itemize}
\end{definition}

Simple and 0-simple semigroups are closely related.  Note that if $S$ is a
simple semigroup, then $S^0$, the semigroup created by appending a zero element
to $S$, is 0-simple.  A 0-simple semigroup's ideals are $\{0\}$ and $S$.
Note also that the trivial semigroup is simple but not 0-simple.

Next, we consider a slightly stronger condition, after a preliminary definition
relating to idempotents.

\begin{definition}
  \label{def:primitive}
  \index{primitive idempotent}
  An idempotent $p \in S$ is \textbf{primitive} if it is non-zero and there is
  no other non-zero idempotent $i \in S$ such that $ip = pi = i$.
\end{definition}

\begin{definition}
  \label{def:completelyzerosimple}
  \index{completely!simple}
  \index{completely!0-simple}
  A semigroup is:
  \begin{itemize}
  \item \textbf{completely simple} if it is simple and contains a primitive
    idempotent;
  \item \textbf{completely 0-simple} if it is 0-simple and contains a primitive
    idempotent.
  \end{itemize}
\end{definition}

Definitions \ref{def:zerosimple} and \ref{def:completelyzerosimple} are
equivalent for finite semigroups -- that is to say, a finite semigroup is
completely simple if and only if it is simple, and it is completely 0-simple if
and only if it is 0-simple.  Some of the conversions described in this chapter
will be applicable only to finite semigroups, and in those circumstances we will
refer to \textit{finite simple} or \textit{finite 0-simple} semigroups, knowing
that these are completely simple or completely 0-simple, respectively.
Note that a finite semigroup is simple if and only if it is $\JJ$-trivial.

Completely simple and completely 0-simple semigroups have a strong and useful
isomorphism property, which allows us to say a great deal about their structure
and, in particular, their congruences.  We will consider first the more
complicated case, that of completely 0-simple semigroups, and then at the end of
this section we will explain how this theory can be adapted for the much less
complicated case, that of completely simple semigroups.

\begin{definition}[{\cite[\S 3.2]{howie}}]
  \label{def:rzms}
  \index{Rees!0-matrix semigroup}
  \nomenclature[M0GILP]{$\mathcal{M}^0[G;I,\Lambda;P]$}{Rees 0-matrix semigroup}
  A \textbf{Rees 0-matrix semigroup} $\mathcal{M}^0[T;I,\Lambda;P]$ is the set
  $$(I \times T \times \Lambda) \cup \{0\}$$
  with multiplication given by
  $$(i,a,\lambda) \cdot (j,b,\mu) = \left\{
    \begin{array}{l l}
      (i,ap_{\lambda j}b, \mu) & \text{if~} p_{\lambda j} \neq 0, \\
      0 & \text{otherwise,}
    \end{array}
  \right.$$
  where
  \begin{itemize}
  \item $T$ is a semigroup,
  \item $I$ and $\Lambda$ are index sets,
  \item $P$ is a $|\Lambda| \times |I|$ matrix with entries $(p_{\lambda
      i})_{\lambda \in \Lambda, i \in I}$
    taken from $T^0$,
  \item $0x=x0=0$ for all $x \in \mathcal{M}^0[T;I,\Lambda;P]$.
  \end{itemize}
\end{definition}

We will require a certain property of the matrix $P$, which we should define
first: we call a matrix \textbf{regular} \index{regular!matrix} if it contains
at least one non-zero entry in each row and each column.

The following theorem shows how we can use Rees 0-matrix semigroups to classify
completely 0-simple semigroups.

\begin{theorem}[Rees]
  \label{thm:rees}
  Every completely 0-simple semigroup is isomorphic to a Rees 0-matrix semigroup
  $\mathcal{M}^0[G;I,\Lambda;P]$, where $G$ is a group and $P$ is regular.
  Conversely, every such Rees 0-matrix semigroup is completely 0-simple.
  \begin{proof}
    Theorem 3.2.3 in \cite{howie}.
  \end{proof}
\end{theorem}

Now we can replace any completely 0-simple semigroup with its isomorphic Rees
0-matrix semigroup when we wish to perform any isomorphism-invariant
calculations -- hence we can restrict our further investigations just to this
type of semigroup.  Note that if $\mathcal{M}^0[G;I,\Lambda;P]$ is finite, then
$G$, $I$, $\Lambda$ and $P$ are all finite.

Next we consider the congruences of a finite 0-simple semigroup.

\begin{definition}[{\cite[\S 3.5]{howie}}]
  \label{def:linked-triple}
  \index{linked triple}
  \nomenclature[N,S,T]{$(N,\sS,\tT)$}{Linked triple}
  \nomenclature[S]{$\sS$}{Relation on column set $I$}
  \nomenclature[T]{$\tT$}{Relation on row set $\Lambda$}
  Let $S$ be a finite Rees 0-matrix semigroup $\mathcal{M}^0[G;I,\Lambda;P]$
  over the group $G$ with regular matrix $P$.  A \textbf{linked triple} on $S$
  is a triple $$(N,\mathcal{S},\mathcal{T})$$ consisting of a normal subgroup
  $N \trianglelefteq G$, an equivalence relation $\mathcal{S}$ on $I$ and an
  equivalence relation $\mathcal{T}$ on $\Lambda$, such that the following are
  satisfied:
  \begin{enumerate}[\rm(i)]
  \item $\mathcal{S} \subseteq \varepsilon_I$, where $\varepsilon_I =
    \left\{(i,j) \in I \times I\, \middle|\, \forall \lambda \in \Lambda:
      p_{\lambda i}=0 \iff p_{\lambda j}=0 \right\}$,
  \item $\mathcal{T} \subseteq \varepsilon_\Lambda$, where $\varepsilon_\Lambda
    = \left\{(\lambda,\mu) \in \Lambda \times \Lambda\, \middle|\, \forall i \in
      I: p_{\lambda i}=0 \iff p_{\mu i}=0 \right\}$,
  \item For all $i,j \in I$ and $\lambda, \mu \in \Lambda$ such that
    $p_{\lambda i}, p_{\lambda j}, p_{\mu i}, p_{\mu j} \neq 0$ and either
    $(i,j) \in \mathcal{S}$ or $(\lambda,\mu) \in \mathcal{T}$, we have
    $q_{\lambda \mu i j} \in N$, where
    $$q_{\lambda \mu i j} = p_{\lambda i} p_{\mu i}^{-1} p_{\mu j} p_{\lambda
      j}^{-1}.$$
  \end{enumerate}
\end{definition}

We can associate the linked triples of a finite 0-simple semigroup with its
non-universal congruences, as follows.

\begin{theorem}
  \label{thm:linked-triple}
  Let $S$ be a Rees 0-matrix semigroup defined with a group and a regular
  matrix.  There exists a bijection $\Gamma$ between the non-universal
  congruences on $S$ and the linked triples on $S$.
  \begin{proof}
    Theorem 3.5.8 in \cite{howie}
  \end{proof}
\end{theorem}

This theorem shows us an alternative way to look at congruences on completely
0-simple semigroups, just as normal subgroups show us an alternative way to look
at congruences on groups.  However, in order to use this at all in a
computational setting, we must have a concrete function $\Gamma$ which we can
use to convert a congruence to a linked triple and back again, rather than just
the knowledge that such a function exists -- indeed, describing such a function
is the purpose of this section.  We define the function $\Gamma$ as follows.

\begin{definition}[{\cite[\S 3.5]{howie}}]
  \label{def:linked-triple-function}
  \index{linked triple!function}
  Let $S$ be a Rees 0-matrix semigroup $\mathcal{M}^0[G;I,\Lambda;P]$ over a
  group $G$ and a regular matrix $P$, and let $\rho$ be a non-universal
  congruence on $S$.
  The \textbf{linked triple function} of $S$ is the function
  $$\Gamma: \rho \mapsto (N_\rho, \mathcal{S}_\rho, \mathcal{T}_\rho),$$
  which maps any non-universal congruence onto a triple whose entries are
  defined as follows.

  The relation $\mathcal{S}_\rho \subseteq I \times I$ is defined by the rule that
  $(i,j) \in \mathcal{S}_\rho$ if and only if $(i,j) \in \varepsilon_I$ and
  $$(i, p_{\lambda i}^{-1}, \lambda) ~\rho~ (j, p_{\lambda j}^{-1}, \lambda)$$
  for all $\lambda \in \Lambda$ such that $p_{\lambda i} \neq 0$ (and hence
  $p_{\lambda j} \neq 0$).  Similarly, the relation
  $\mathcal{T}_\rho \subseteq \Lambda \times \Lambda$ is defined by the rule that
  $(\lambda,\mu) \in \mathcal{T}_\rho$ if and only if
  $(\lambda,\mu) \in \varepsilon_\Lambda$ and
  $$(i, p_{\lambda i}^{-1}, \lambda) ~\rho~ (i, p_{\mu i}^{-1}, \mu)$$
  for all $i \in I$ such that $p_{\lambda i} \neq 0$ (and hence
  $p_{\mu i} \neq 0$).  Finally, we define the normal subgroup
  $N_\rho \trianglelefteq G$ as follows.  First, fix some $\xi \in \Lambda$, a
  row of the matrix $P$.  Since $P$ is regular, row $\xi$ must contain a
  non-zero entry -- fix some $k \in I$ such that $p_{\xi k} \neq 0$.  Now we can
  define
  $$N_\rho = \{a \in G ~|~ (k, a, \xi) ~\rho~ (k, 1_G, \xi)\},$$
  where $1_G$ is the identity in the group $G$.
  The inverse of $\Gamma$ is then such that
  $(N, \mathcal{S}, \mathcal{T})\Gamma^{-1}$ is equal to
  $$\Big\{
  \big((i, a, \lambda), (j, b, \mu)\big) ~\Big|~
  (p_{\xi i} a p_{\lambda x}) (p_{\xi j} b p_{\mu x})^{-1} \in N,
  (i,j) \in \mathcal{S},
  (\lambda,\mu) \in \mathcal{T}
  \Big\},$$
  where $\xi \in \Lambda$ and $x \in I$ can be any elements such that
  $p_{\xi i}$ and $p_{\lambda x}$ are both non-zero.
\end{definition}

Note that the definition of $N_\rho$ does not depend on the choice of $\xi$ and
$k$.  Independence from the choice of $\xi$ is established by the following
lemma, and independence from the choice of $k$ follows by a similar argument.

\begin{lemma}
  Let $\xi_1, \xi_2 \in \Lambda$ and $k \in I$ such that $p_{\xi_1k}^{} \neq 0$
  and $p_{\xi_2 k}^{} \neq 0$.  Then
  $$(k, a, \xi_1) ~\rho~ (k, 1_G, \xi_1)
  \quad \text{if and only if} \quad
  (k, a, \xi_2) ~\rho~ (k, 1_G, \xi_2)$$
  for all $a \in G$.
  \begin{proof}
    Assume that $(k, a, \xi_1) ~\rho~ (k, 1_G, \xi_1)$.  We can right-multiply
    both sides by $(k, p_{\xi_1k}^{-1}, \xi_2)$ to give
    $$(k, a, \xi_1)(k, p_{\xi_1k}^{-1}, \xi_2)
    ~\rho~ (k, 1_G, \xi_1)(k, p_{\xi_1k}^{-1}, \xi_2),$$
    which simplifies to
    $$(k, a p_{\xi_1k}^{} p_{\xi_1k}^{-1}, \xi_2)
    ~\rho~ (k, 1_G p_{\xi_1k}^{} p_{\xi_1k}^{-1}, \xi_2),$$
    and then to
    $(k, a, \xi_2) ~\rho~ (k, 1_G, \xi_2)$,
    as required.
    The converse argument is identical, swapping $\xi_1$ for $\xi_2$.
  \end{proof}
\end{lemma}

\index{Rees!matrix semigroup}
\nomenclature[MGILP]{$\mathcal{M}[G;I,\Lambda;P]$}{Rees matrix semigroup}
Our discussion so far has focused on 0-simple semigroups, but very similar
structures exist for completely \textit{simple} semigroups.  They are isomorphic
to \textbf{Rees matrix semigroups}, and linked triples can be defined on them in
almost exactly the same way, except for the removal of complications related to
the zero element.  A Rees matrix semigroup follows Definition \ref{def:rzms} but
with the removal of the zero element, and linked triples follow Definition
\ref{def:linked-triple}, where the restrictions related to placements of $0$ in
$P$ are irrelevant.  It should also be noted that even the universal congruence
has a linked triple in this
case -- $(G, I \times I, \Lambda \times \Lambda)$ -- so the domain of $\Gamma$ is
not only the non-universal congruences, but all congruences on $S$.

\subsection{Inverse semigroups: kernel--trace pairs}
\label{sec:kertr}
% TODO? Wilf's book about semilattice congruences: Symmetric Inverse Semigroups

An inverse semigroup also has a structure which can be used in place of its
congruences: its \textit{kernel--trace pairs} (sometimes confusingly known as
``congruence pairs'').  In \cite[Chapter 5]{mtorpey_msc} the author focused on a
computational use of kernel--trace pairs to solve problems about congruences.
They can certainly be used effectively to carry out calculations, in a similar
way to linked triples.

The basic theory about kernel--trace pairs is presented here, for reference.  In
all these definitions, $S$ is an inverse semigroup, $E$ is the set of
idempotents in $S$, and and $\rho$ is a congruence on $S$.  Recall that $E$ is
an inverse subsemigroup of $S$.  This is standard background theory, which is
adapted from \cite[\S 5.3]{howie}.

\begin{definition}
  \label{def:kernel-cong}
  \index{kernel!of a congruence}
  The \textbf{kernel} of $\rho$ is $\bigcup_{e \in E} [e]_\rho$, the union of
  all the $\rho$-classes of $S$ which contain idempotents.  It is denoted by
  $\ker\rho$.
\end{definition}

\begin{definition}
  \label{def:trace}
  \index{trace}
  The \textbf{trace} of $\rho$ is $\rho \cap (E \times E)$, the restriction of
  $\rho$ to the idempotents of $S$.  It is denoted by $\tr\rho$.
\end{definition}

We will shortly see that a congruence on $S$ is completely defined by its kernel
and trace.  First we will approach kernel--trace pairs from an abstract route
which will help us to classify the congruences on $S$ completely.  We start with
two different definitions of the word ``normal'', one for subsemigroups and one
for congruences.

\begin{definition}
  \label{def:kernel-normal}
  \index{normal!subsemigroup}
  A subsemigroup $K$ of $S$ is called \textbf{normal} if it is
  \textit{full} (contains all the idempotents of $S$) and
  \textit{self-conjugate} ($a^{-1}xa \in K$ for all $x \in K, a \in S$).
\end{definition}

\begin{definition}
  \label{def:trace-normal}
  \index{normal!congruence}
  A congruence $\tau$ on $E$ is \textbf{normal} in $S$ if
  $$(a^{-1}ea,a^{-1}fa) \in \tau$$
  for every pair $(e,f) \in \tau$ and every element $a \in S$.
\end{definition}

Now we can define a \textit{kernel--trace pair}, an abstract structure which
relates very closely to a congruence.

\begin{definition}
  \label{def:kernel-trace-pair}
  \index{kernel--trace pair!for an inverse semigroup}
  A \textbf{kernel--trace pair} on $S$ is a pair $(K,\tau)$ consisting of a
  normal subsemigroup $K$ of $S$ and a normal congruence $\tau$ on $E$, such
  that
  \begin{enumerate}[\rm(i)]
  \item If $ae \in K$ and $(e,a^{-1}a) \in \tau$, then $a \in K$
  \item If $a \in K$, then $(aa^{-1},a^{-1}a) \in \tau$
  \end{enumerate}
  for all elements $a \in S$ and $e \in E$.
\end{definition}

Now we state the result which identifies an abstract kernel--trace pair with the
kernel and trace of a congruence, and allows us to calculate information about
$\rho$ by using $\ker \rho$ and $\tr \rho$ directly.

\begin{theorem}
  \label{thm:kernel-trace-pair}
  % Let $\rho$ be a congruence on an inverse semigroup $S$ with idempotent
  % semigroup $E$.  $(\ker\rho, \tr\rho)$ is a kernel--trace pair.

  % Conversely, every kernel--trace pair $(K,\tau)$ on $S$ defines a congruence
  % $$\rho_{(K,\tau)} = \{(x,y) \in S \times S ~|~ (x^{-1}x, y^{-1}y) \in \tau,
  % xy^{-1} \in K\}$$
  % whose kernel is equal to $K$ and whose trace is equal to $\tau$.  Finally,
  % $\rho_{(\ker\rho,\tr\rho)} = \rho$.
  Let $S$ be an inverse semigroup.  There exists a bijection $\Psi$ from the
  congruences on $S$ to the kernel--trace pairs on $S$, defined by
  $$\Psi: \rho \mapsto (\ker\rho, \tr\rho),$$
  and its inverse satisfies
  $$\Psi^{-1} : (K,\tau) \mapsto
  \{(x,y) \in S \times S ~|~ xy^{-1} \in K, (x^{-1}x, y^{-1}y) \in \tau\}.$$
  \begin{proof}
    Theorem 5.3.3 in \cite{howie}.
  \end{proof}
\end{theorem}

This theorem tells us everything we need to know about kernel--trace pairs and
their relationship to congruences on an inverse semigroup.  Once we have the
kernel--trace pair of a congruence, we can solve any problem we wish to using the
kernel and trace alone, and computational problems such as determining whether a
given pair $(x,y)$ lies in the congruence are much faster than using
generating pairs directly \cite[\S 6.1.3]{mtorpey_msc}.  However, we may find
that if a congruence is specified initially using generating pairs, it may be
costly to find its kernel--trace pair in the first place; Section
\ref{sec:pairs-to-kertr} presents a relatively fast method for finding a kernel--trace pair.

\subsection{Rees congruences}
\label{sec:converting-rees}
Recall that a \textit{Rees congruence} is a congruence on a semigroup $S$ with a
distinguished congruence class $I$ which is a two-sided ideal of $S$, and in
which every other congruence class is a singleton.  We may write this congruence
as $\rho_I$, and we may write its quotient $S/\rho_I$ as $S/I$.  Hence, a pair
$(x,y)$ lies in $\rho_I$ if and only if $x=y$ or $x$ and $y$ both lie in $I$.

Some or all of a semigroup's congruences may be Rees: in particular, since $S$
is an ideal of $S$, the universal congruence $S \times S$ is a Rees congruence
which could be written as $\rho_S$.  If $S$ has a zero $0$, then $\{0\}$ is an
ideal and so the trivial congruence $\Delta_S$ is a Rees congruence which could
be written as $\rho_{\{0\}}$.

As an example, the monoid of all order-preserving transformations $\OO_n$ has
only Rees congruences, apart from the trivial congruence $\Delta_{\OO_n}$, which
is not Rees, since $\OO_n$ does not contain a zero \cite{lavers_1999}.
Some examples of semigroups whose congruences are all Rees can be found in
\cite[\S 5]{garcia_1991}.

\section{Converting between representations}
\label{sec:converting}

In Section \ref{sec:ways-of-representing} we presented five different ways of
representing a congruence.  In this section, we present a survey of the
different ways in which they can be converted to each other.  Table
\ref{tab:converting} summarises the methods which exist, and the sections in
which they are described.

\subsection{Normal subgroups and linked triples}
\label{sec:normal-subgroup-to-linked-triple}
In this section we will consider how to convert between a normal subgroup (which
represents a congruence on a group) and a linked triple (which represents a
congruence on a simple semigroup).  This conversion is rather trivial, but is
presented as a good example of how different congruence representations can be
closely related.

Any group is a completely simple semigroup.  In fact, since any group $G$ has
precisely one $\HH$-class, it is isomorphic to the Rees matrix semigroup
$\mathcal{M}[G; I, \Lambda; P]$ where $|I|=|\Lambda|={1}$ and $P$ is the
$1 \times 1$ matrix $(1_G)$.  Let $\phi: G \to \mathcal{M}[G; I, \Lambda; P]$ be
the isomorphism defined by $(g)\phi = (1, g, 1)$.

As described in Theorem \ref{thm:normal-subgroups}, a congruence $\rho$ on a
group $G$ is associated with a normal subgroup $N \trianglelefteq G$, according
to the rule that $x ~\rho~ y$ if and only if $xy^{-1} \in N$.  Similarly, as
described in Definition \ref{def:linked-triple-function}, a congruence $\rho'$
on $\mathcal{M}[G; I, \Lambda; P]$ is associated with a linked triple
$(N', \mathcal{S}, \mathcal{T})$, according to the rule that
$(i, a, \lambda) ~\rho~ (j, b, \mu)$ if and only if $i ~\mathcal{S}~ j$,
$\lambda ~\mathcal{T}~ \mu$, and
$(p_{1 i} a p_{\lambda 1}) (p_{1 j} b p_{\mu 1})^{-1} \in N'$.
Since $|I|=|\Lambda|={1}$ and $P=(1_G)$, this last condition simplifies to
$ab^{-1} \in N'$.

Let $\rho'$ be the congruence on $\mathcal{M}[G; I, \Lambda; P]$ such that
$(x)\phi ~\rho'~ (y)\phi$ (i.e.~$(1,x,1) \mathrel{\rho'} (1,y,1)$) if and only if
$x ~\rho~ y$.  The condition defining $\rho$, that $xy^{-1} \in N$, is
equivalent to the condition defined by the linked triple
$(N, \Delta_I, \Delta_\Lambda)$, since $I$ and $\Lambda$ are both trivial.
Hence any normal subgroup $N$ corresponds to the linked triple
$(N, \Delta_I, \Delta_\Lambda)$, making linked triples on groups very easy to
deal with.

\subsection{Generating pairs of a Rees congruence}
\label{sec:rees-to-pairs}
A natural question, given an ideal $I$, is how to find a set of generating pairs
for the Rees congruence $\rho_I$.  In this section we will limit our discussion
to finite semigroups.

\begin{theorem}
  Let $S$ be a finite semigroup, and let $I$ be an ideal of $S$.  If $X$ is an ideal
  generating set for $I$ (see Section \ref{sec:intro-ideals}) and $M$
  is the minimal ideal of $S$ (which may or may not be equal to $I$), then
  $$X \times M$$ is a set of generating pairs for the Rees congruence $\rho_I$.
  \begin{proof}
    Let $\rho$ be the congruence generated by $X \times M$.  First we show that
    $\rho \subseteq \rho_I$, and then that $\rho_I \subseteq \rho$.

    Let $(i,m) \in X \times M$.  We have $X \subseteq I$ since $X$ is a
    generating set for $I$, and $M \subseteq I$ since $M$ is contained in any
    ideal of $S$.  Hence $i$ and $m$ both lie in $I$, so they are in the same
    class of the Rees congruence: $(i,m) \in \rho_I$.  Hence $X \times M
    \subseteq \rho_I$, and so $\rho$ (the least congruence containing $X \times
    M$) must also be contained in $\rho_I$.  Hence $\rho \subseteq \rho_I$.

    Now let $(a,b) \in \rho_I$; we wish to show that $(a,b) \in \rho$.  If $a=b$
    then we certainly have $(a,b) \in \rho$.  Otherwise we must have $a,b \in
    I$.  Since $X$ \textit{generates} $I$, we have $I = S^1XS^1$.  Therefore we
    can write
    $$a = s_1x_1t_1, \quad b = s_2x_2t_2,$$
    for some $x_1,x_2 \in X$ and $s_1,s_2,t_1,t_2 \in S^1$.

    Now choose some $m \in M$.  By definition $(x_1,m), (x_2,m) \in \rho$ since
    $X \times M \subseteq \rho$, and
    by the compatibility properties of a congruence,
    $$(s_1x_1t_1,s_1mt_1), (s_2x_2t_2,s_2mt_2) \in \rho.$$

    Since $m \in M$, we must have $s_1mt_1,s_2mt_2 \in M$.  Let $x_0$ be an
    arbitrary element of $X$.
    We see $(x_0,s_1mt_1), (x_0,s_2mt_2) \in X \times M$, and so by transitivity
    $(s_1mt_1, s_2mt_2) \in \rho$.
    Hence
    $$a ~=~ s_1x_1t_1 ~\rho~ s_1mt_1 ~\rho~ s_2mt_2 ~\rho~ s_2x_2t_2 = b,$$
    and $(a,b) \in \rho$ as required.
  \end{proof}
\end{theorem}

\subsection{Linked triple from generating pairs}
\label{sec:pairs-to-linked-triple}

In \cite[\S 6.1]{mtorpey_pre_msc} it is observed that calculating information
about a congruence using its linked triple is much faster than using a set of
generating pairs.  However, it may well be that a congruence on a finite
simple or finite 0-simple semigroup is specified by generating pairs, and we do
not know its linked triple \textit{a priori}.  In this case, we will need to
calculate the congruence's linked triple before we can use it to calculate any
other information.  We could do this by enumerating all the elements of all the
classes of the congruence, and then simply looking up the relevant information
to find the linked triple.  However, this is very expensive, and once the
classes are enumerated there is likely no need for the linked triple, since all
information about the congruence has already been calculated.

In \cite[\S 3.2]{mtorpey_msc}, the author presents an algorithm to calculate a
congruence's linked triple directly from a set of generating pairs, calculating
as few extra pairs as possible.  This algorithm performs quickly, representing a
big improvement on using a more na\"ive algorithm to find the linked triple
\cite[\S 6.1.2]{mtorpey_msc}.  The algorithm is justified by the following
definition and theorem from \cite{mtorpey_msc}.

\begin{definition}[{\cite[Definition 3.10]{mtorpey_msc}}]
  \label{def:ri}
  Let $S = \mathcal{M}^0[G;I,\Lambda;P]$ be a finite Rees 0-matrix semigroup
  over a group $G$ with regular matrix $P$, and let $\R \subseteq S \times S$ be
  a relation on it.  We define the relations $\R|_I$ and $\R|_\Lambda$ by
  $$\R|_I = \big\{(i,j) \in I \times I ~\big|~
  (i,a,\lambda) ~\R~ (j,b,\mu)\big\},$$
  % ~\text{for some}~a,b \in G,~\lambda,\mu \in \Lambda\big\},$$
  $$\R|_\Lambda = \big\{(\lambda,\mu) \in \Lambda \times \Lambda ~\big|~
  (i,a,\lambda) ~\R~ (j,b,\mu)\big\}.$$
  % ~\text{for some}~a,b \in G,~i,j \in I\big\}.$$
\end{definition}

\begin{theorem}[{\cite[Theorem 3.11]{mtorpey_msc}}]
  \label{thm:pairs-to-linked-triple}
  Let $S = \mathcal{M}^0[G;I,\Lambda;P]$ be a finite 0-simple semigroup over a
  group $G$ with regular matrix $P$, with a relation $\R \subseteq S \times S$
  that generates a non-universal congruence $\R^\sharp$.  Let
  $\mathcal{S}_{\Rs} = (\R|_I)^e$, let
  $\mathcal{T}_{\Rs} = (\R|_\Lambda)^e$, and let $N_{\Rs}$ be
  the least normal subgroup of $G$ containing the set
  \begin{align*}
    \Big\{(p_{\xi i} a p_{\lambda x}) (p_{\xi j} b p_{\mu x})^{-1} ~\Big|~
    & i,j,x \in I,\ \lambda, \mu, \xi \in \Lambda,\ a,b \in G \\
    & \text{such that~} (i,a,\lambda) ~\R~ (j,b,\mu) \text{~and~}
      p_{\xi i}, p_{\lambda x} \neq 0\Big\} \\
    \cup~ \Big\{q_{\lambda \mu i j} ~\Big|~ &
           (i,j) \in \R|_I,~
           \lambda,\mu \in \Lambda ~\textnormal{such that}~
           p_{\lambda i}, p_{\mu i} \neq 0\Big\} \\
    \cup~ \Big\{q_{\lambda \mu i j} ~\Big|~ &
           (\lambda,\mu) \in \R|_\Lambda,~
           i,j \in I ~\textnormal{such that}~
           p_{\lambda i}, p_{\lambda j} \neq 0\Big\}. \\
  \end{align*}
  Then $(N_{\Rs}, \mathcal{S}_{\Rs}, \mathcal{T}_{\Rs})$
  is the linked triple corresponding to $\R^\sharp$.
\end{theorem}

This theorem is enough to show the correctness of our algorithm for converting a
set of generating pairs to a linked triple -- we present this algorithm here as
Algorithm \ref{alg:pairs-to-linked-triple}.  In reading the algorithm, it will
be helpful to refer to Definition \ref{def:linked-triple} for the relations
$\varepsilon_I$ and $\varepsilon_\Lambda$ and elements of the form
$q_{\lambda \mu i j}$.  The notation $\llangle N, x \rrangle$ describes the
least normal subgroup of $G$ containing $N \cup \{x\}$ (see Definition
\ref{def:normal-closure}); in particular, this is equal to $N$ if $x \in N$.
We will now give a brief description of how the algorithm operates, with
reference to the pseudo-code in Algorithm \ref{alg:pairs-to-linked-triple}.
For a fuller description of the algorithm and how it is justified by Theorem
\ref{thm:pairs-to-linked-triple}, see \cite[\S 3.2]{mtorpey_msc}.

The \textsc{LinkedTripleFromPairs} algorithm starts with the minimal linked
triple possible: $(N, \sS, \tT) = \big(\{1_G\}, \Delta_I, \Delta_\Lambda\big)$,
where $\{1_G\}$ is the trivial subgroup of $G$, and $\Delta_I$ and
$\Delta_\Lambda$ are the trivial equivalences on the sets of columns and rows in
the matrix $P$.  This is the linked triple that corresponds to the trivial
congruence $\Delta_S$, which is the result that should be returned if $\R$ is
empty.  The rest of the algorithm (lines 5--24) consist of going through each
pair in $\R$, adding any necessary extra elements to $N$, $\sS$ and $\tT$
that are implied by that pair, and finally adding further elements to ensure
that $(N, \sS, \tT)$ remains a linked triple.

For each pair $(x,y) \in \R$, we first check whether $x=y$ (line 6) -- if so, it
is a pair in $\Delta_S$ and we do not need to do anything to the linked triple
in order to account for it.  If $x \neq y$, then we need to check whether one of
$x$ or $y$ is equal to zero; if so, we have a non-zero element related to zero,
which means that $\Rs$ must be the universal congruence, which has no linked
triple, and we quit the algorithm immediately returning this information (line
9).

If neither element is zero, then $x$ and $y$ must be non-zero elements, which we
can rewrite as $(i,a,\lambda)$ and $(j,b,\mu)$ (lines 10--11).  Before we try
modifying the linked triple, we check that columns $i$ and $j$, and rows
$\lambda$ and $\mu$, have zeroes in the same places in the matrix $P$ (line 12);
if not, they cannot be related by a linked triple, so we again have the
universal congruence, and quit the algorithm immediately (line 13).  If this
check does not reveal a problem, we can proceed to add information to the
triple, first by uniting the columns $(i,j)$ in $\sS$, and then by uniting the
rows $(\lambda, \mu)$ in $\tT$ (lines 15--16).  This could perhaps be tracked
using a union--find table for each of $\sS$ and $\tT$ (see Section
\ref{sec:union-find}).

Next we modify the normal subgroup $N$ by adding an element based on the group
elements $a$ and $b$ (lines 18--20), in line with the definition of
$\Gamma^{-1}$ in Definition \ref{def:linked-triple-function}.  As we add this,
we add any necessary elements to $N$ to make it a normal subgroup (taking its
\textit{normal closure}).  And finally, we add any necessary elements of the
form $q_{\lambda \mu i j}$ to make $N$ compatible with Definition
\ref{def:linked-triple} condition (iii) (lines 21--24).  At the end of this, we
have a triple $(N,\sS,\tT)$ which is linked, and whose congruence contains every
pair in $\R$.  Since we added no elements but those required by $\R$ and the
definition of a linked triple, we can be certain that $(N,\sS,\tT)$ describes
$\Rs$, the least congruence containing all the pairs in $\R$.  Again, see
\cite[\S 3.2]{mtorpey_msc} for a full justification of the algorithm.

\begin{algorithm}
\caption{The \textsc{LinkedTripleFromPairs} algorithm}
\label{alg:pairs-to-linked-triple}
\index{LinkedTripleFromPairs@\textsc{LinkedTripleFromPairs}}
\begin{algorithmic}[1]
    \Require $\mathcal{M}^0[G;I,\Lambda;P]$ a finite Rees 0-matrix semigroup
    \Require $G$ a group, $P$ a regular matrix
    \Procedure{LinkedTripleFromPairs}{$\R$}
      \State $N := \{1_G\}$
      \State $\mathcal{S} := \Delta_I$
      \State $\mathcal{T} := \Delta_\Lambda$
      \For{$(x,y) \in \R$}
        \If{$x=y$}
          \State \Continue
        \ElsIf{$x=0 \Or y=0$}
          \State \Return Universal Congruence (no linked triple)
        \EndIf
        \State Let $x=(i,a,\lambda)$
        \State Let $y=(j,b,\mu)$
        \If{$(i,j) \notin \varepsilon_I \Or
          (\lambda,\mu) \notin \varepsilon_\Lambda$}
          \State \Return Universal Congruence (no linked triple)
        \EndIf

%        \State
        \LComment{Combine row and column classes}
        \State $\sS \gets \left(\sS \cup (i,j)\right)^e$
        \State $\tT \gets \left(\tT \cup (\lambda, \mu)\right)^e$

%        \State
        \LComment{Add generators for normal subgroup}
        \State Choose $\nu \in \Lambda$ such that $p_{\nu i} \neq 0$
        \State Choose $k \in I$ such that $p_{\lambda k} \neq 0$
        \State $N \gets \llangle N, (p_{\nu i}ap_{\lambda k})(p_{\nu j}bp_{\mu k})^{-1} \rrangle$

%        \State
        \For{$\xi \in \Lambda \setminus \{\nu\}$ such that $p_{\xi i} \neq 0$}
          \State $N \gets \llangle N, q_{\nu \xi i j} \rrangle$
        \EndFor
        \For{$x \in I \setminus \{k\}$ such that $p_{\lambda x} \neq 0$}
          \State $N \gets \llangle N, q_{\lambda \mu k x} \rrangle$
        \EndFor
      \EndFor
      \State \Return $(N,\mathcal{S},\mathcal{T})$
    \EndProcedure
\end{algorithmic}
\end{algorithm}

We can see the algorithm working in the following example.

\begin{example}
  \label{ex:pairs-to-linked-triple-4x2}
  Let $S = \mathcal{M}^0[\mathcal{D}_4; \{1,2,3,4\}, \{1,2\}; P]$ be a Rees
  0-matrix semigroup, where $\mathcal{D}_4$ is the permutation group
  $\langle (1~2~3~4), (2~4) \rangle$, isomorphic to the dihedral group on $4$
  points, and $P$ is the $2 \times 4$ matrix
  $$
  \begin{pmatrix}
    0 & (1~2)(3~4) & 0 & (1~4~3~2) \\
    (2~4) & (1~4)(2~3) & (2~4) & 0
  \end{pmatrix}.
  $$
  Let $\rho$ be the congruence generated by the single pair
  $\big(\left(1, (), 1\right), \left(3, (1~2~3~4), 1\right)\big)$.  We can
  use \textsc{LinkedTripleFromPairs} to find the linked triple corresponding to
  $\rho$, or to determine that $\rho$ is universal.

  We set our triple to $\big(\{()\}, \Delta_4, \Delta_2\big)$ to start with, where
  $\Delta_n$ is the diagonal relation on $\{1, \ldots, n\}$.  Then we consider
  the single pair in the generating set: $x = \left(1, (), 1\right)$ and
  $y = \left(3, (1~2~3~4), 1\right)$.  We do not have $x=y$, $x=0$ or $y=0$, so
  we go on to consider the two elements componentwise.  The pair $(i,j) = (1,3)$
  lies in $\varepsilon_I$ since columns $1$ and $3$ contain zeroes in the same
  positions, and $(\lambda,\mu) = (1,1)$ certainly lies in $\varepsilon_\Lambda$
  since it is a reflexive pair; hence we do not have to return the universal
  congruence.  We modify $\sS$ by joining the classes of $1$ and $3$ together;
  we do not have to modify $\tT$, since $(1,1)$ is already in $\tT$.  Finally we
  have to add generators to $N$: we can set both $\nu$ and $k$ to $2$, and then
  we add to $N$ the element
  \begin{align*}
    (p_{\nu i}ap_{\lambda k})(p_{\nu j}bp_{\mu k})^{-1}
    &= \left(p_{2 1}()p_{1 2}\right)\left(p_{2 3}(1~2~3~4)p_{1 2}\right)^{-1} \\
    &= \left((2~4)()(1~2)(3~4)\right)\left((2~4)(1~2~3~4)(1~2)(3~4)\right)^{-1}\\
    &= (1~2~3~4),
  \end{align*}
  and take the normal closure.  Finally we have to add any appropriate $q$
  values.  There is no value of $\xi$ which meets the stated requirements, but
  there is one appropriate value for $x$: $x = 4$.  Hence we have to add the
  element
  $q_{\lambda \mu k x}
  = q_{1 1 2 4}
  = p_{1 2} p_{1 2}^{-1} p_{1 4} p_{1 4}^{-1}
  = ()$.
  Since the identity already lies in $N$, we do not need to make any changes.
  There are no more pairs to process, so we return the linked triple
  $(N,\sS,\tT) = (\mathcal{C}_4, (1,3)^e, \Delta_2)$, where
  \begin{itemize}
  \item $\mathcal{C}_4 = \langle (1~2~3~4) \rangle$ is the subgroup of
    $\mathcal{D}_4$ consisting of the four rotations, isomorphic to the cyclic
    group of order $4$;
  \item $(1,3)^e$ is the least equivalence on $\{1,2,3,4\}$ containing the pair
    $(1,3)$ (its classes are $\{1,3\}$, $\{2\}$, and $\{4\}$);
  \item $\Delta_2$ is the diagonal relation on $\{1,2\}$ (its classes are
    $\{1\}$ and $\{2\}$).
  \end{itemize}
\end{example}

\subsection{Generating pairs from a linked triple}
\label{sec:linked-triple-to-pairs}

Let $S$ be a completely simple or completely 0-simple semigroup, and let $\rho$
be a congruence on $S$.  In Section \ref{sec:pairs-to-linked-triple} we
presented an algorithm to find the linked triple of $\rho$, given only a set of
generating pairs for $\rho$.  In this section, we will present the reverse: an
method to find a set of generating pairs for $\rho$ given only its linked triple
$(N, \mathcal{S}, \mathcal{T})$.

Firstly we require a lemma describing the inclusion of congruences in each
other, and how it mirrors an inclusion of linked triples.

\begin{lemma}[{\cite[Lemma 3.5.5]{howie}}, {\cite[Lemma 3.9]{mtorpey_msc}}]
  \label{lem:linked-triple-subsets}
  Let $\rho$ and $\sigma$ be congruences on $S$ with linked triples
  $(N_\rho, \mathcal{S}_\rho, \mathcal{T}_\rho)$ and
  $(N_\sigma, \mathcal{S}_\sigma, \mathcal{T}_\sigma)$ respectively.
  We have $\rho \subseteq \sigma$ if and only if
  $N_\rho \leq N_\sigma$,
  $\mathcal{S}_\rho \subseteq \mathcal{S}_\sigma$, and
  $\mathcal{T}_\rho \subseteq \mathcal{T}_\sigma$.
\end{lemma}

Now we can state the main theorem which will inform this algorithm.  It also
relies on ideas from Theorem \ref{thm:pairs-to-linked-triple}.

\begin{theorem}
  \label{thm:linked-triple-to-pairs}
  Let $S = \mathcal{M}^0[G;I,\Lambda;P]$ be a finite 0-simple semigroup, and let
  $\rho$ be a congruence with linked triple $(N_\rho, \sS_\rho, \tT_\rho)$.  Let
  $N_\rho' \subseteq N_\rho$, $\sS_\rho' \subseteq \sS_\rho$ and
  $\tT_\rho' \subseteq \tT_\rho$ be any subsets with the following properties:
  \begin{itemize}
  \item $N_\rho$ is the normal closure of $N_\rho'$ in $G$,
  \item $\sS_\rho = (\sS_\rho')^e$,
  \item $\tT_\rho = (\tT_\rho')^e$.
  \end{itemize}
  If $\R$ is a subset of $\rho$ such that
  \begin{enumerate}[\rm(i)]
  \item for each pair $(i, j) \in \sS_\rho'$ there exist $\lambda, \mu \in \Lambda$
    and $a, b \in G$ such that $(i, a, \lambda) ~\R~ (j, b, \mu)$;
  \item for each pair $(\lambda, \mu) \in \tT_\rho'$ there exist $i, j \in I$ and
    $a, b \in G$ such that $(i, a, \lambda) ~\R~ (j, b, \mu)$;
  \item for each element $n \in N_\rho'$ there exist $i,j,x \in I$ and $\lambda,
    \mu, \xi \in \Lambda$ such that $p_{\xi i}$ and $p_{\lambda x}$ are both
    non-zero and
    $$(i, p_{\xi i}^{-1} n p_{\lambda x}^{-1}, \lambda) ~\R~
    (j, p_{\xi j}^{-1} p_{\mu x}^{-1}, \mu);$$
  \end{enumerate}
  then $\R^\sharp = \rho$.

  \begin{proof}
    Assume $\R$ is as stated.  Since $\rho$ is a congruence and
    $\R \subseteq \rho$, we know that $\R^\sharp \subseteq \rho$.  Hence we only
    need to show that $\rho \subseteq \R^\sharp$.

    Let $(N_{\Rs}, \sS_{\Rs}, \tT_{\Rs})$ denote the linked triple associated with
    $\R^\sharp$.  We will show that $N_\rho \subseteq N_{\Rs}$,
    $\sS_\rho \subseteq \sS_{\Rs}$, and $\tT_\rho \subseteq \tT_{\Rs}$, and therefore
    that $\rho \subseteq \R$ by Lemma \ref{lem:linked-triple-subsets}.

    Recall the relations $\R_I$ and $\R_\Lambda$ from Definition \ref{def:ri}.
    By (i) we can see that $\sS_\rho' \subseteq \R_I$ and hence
    $(\sS_\rho')^e \subseteq (\R_I)^e$.  Meanwhile by Theorem
    \ref{thm:pairs-to-linked-triple} we have $(\R_I)^e = \mathcal{S}_{\Rs}$.  In
    total this gives us
    $\sS_\rho = (\sS_\rho')^e \subseteq (\R_I)^e = \mathcal{S}_{\Rs}$, so
    $\sS_\rho \subseteq \sS_{\Rs}$.  Similarly by (ii) we have
    $\tT_\rho \subseteq \tT_{\Rs}$.

    Now we turn our attention to $N_\rho$, and its generating set $N_\rho'$ -- we
    wish to show that $N_\rho \subseteq N_{\Rs}$.  Let $n \in N_\rho'$.  By (iii),
    there exist $i, j, x \in I$ and $\lambda, \mu, \xi \in \Lambda$ such that
    $p_{\xi i}$ and $p_{\lambda x}$ are both non-zero and
    $(i, a, \lambda) ~\R~ (j, b, \mu)$, where
    $$a = p_{\xi i}^{-1} n p_{\lambda x}^{-1} \qquad \text{and} \qquad
    b = p_{\xi j}^{-1} p_{\mu x}^{-1}.$$
    Note that $p_{\xi j}$ and $p_{\mu x}$
    must also be non-zero since $(i, j) \in \varepsilon_I$ and
    $(\lambda, \mu) \in \varepsilon_\Lambda$.  To see that $n \in N_{\Rs}$, observe
    that $p_{\xi i} a p_{\lambda x} = n$ and $p_{\xi j} b p_{\mu x} = 1_G$.
    Hence $n$ satisfies the condition that
    $$n = (p_{\xi i} a p_{\lambda x}) (p_{\xi j} b p_{\mu x})^{-1}$$
    for some $i,j,x \in I$, some $\lambda, \mu, \xi \in \Lambda$, and some
    $a,b \in G$ such that $(i,a,\lambda) ~\R~ (j,b,\mu)$ and $p_{\xi i}$
    and $p_{\lambda x}$ are non-zero; this is precisely the requirement in
    Theorem \ref{thm:pairs-to-linked-triple} which means that $n \in N_{\Rs}$.
    Hence $N_\rho' \subseteq N_{\Rs}$.  And since $N_\rho$ is the normal closure of
    $N_\rho'$, and $N_{\Rs}$ is a normal subgroup, we have $N_\rho \subseteq N_{\Rs}$.

    Since $N_\rho \subseteq N_{\Rs}$, $\sS_\rho \subseteq \sS_{\Rs}$ and
    $\tT_\rho \subseteq \tT_{\Rs}$, Lemma \ref{lem:linked-triple-subsets} gives us
    $\rho \subseteq \R^\sharp$, as required.
  \end{proof}
\end{theorem}

Theorem \ref{thm:linked-triple-to-pairs} is enough to justify the
\textsc{PairsFromLinkedTriple} algorithm, which is presented in this
thesis as Algorithm \ref{alg:linked-triple-to-pairs}.  Given a linked triple
$(N, \sS, \tT)$, we only need to choose applicable subsets $N' \subseteq N$,
$\sS' \subseteq \sS$ and $\tT' \subseteq \tT$ and we have a
good idea of what pairs are necessary to generate a congruence.  In the
algorithm, we assume that a generating set $N'$ is known for $N$ (line 2) -- this is
certainly likely to be the case in a computational setting, for example in \GAP{}
\cite{gap} where groups almost always have a known generating set.  We should
note that this set should act as a set of normal subgroup generators, meaning
that it might be even smaller than a standard set of subgroup generators.  For
$\sS'$ we choose a minimal spanning tree of depth $1$ for each class of $\sS$, by linking
each column in the class to a distinguished class representative called $i_1$
(lines 3--7).
Hence each class requires a number of pairs in $\sS'$ equal to one less than the
size of the class; and so $|\sS'| = |I| - k_\sS$, where $k_\sS$ is the number
of classes in $\sS$.  We similarly choose a minimal spanning tree of depth 1 for
$\tT'$ (lines 8--12), so $|\tT'| = |\Lambda| - k_\tT$, where $k_\tT$ is
the number of classes in $\tT$.

Once our three generating sets have been calculated, we collate them into the
set of pairs $\R$ as efficiently as possible: each pair we add to $\R$ can
satisfy the conditions in Theorem \ref{thm:linked-triple-to-pairs} for one pair
$(i,j) \in \sS'$, one pair $(\lambda, \mu) \in \tT'$, and one element
$n \in N'$.  The while-loop on lines 17--26 steps through the three lists, on
each iteration taking a new element $a$ from $N'$, a new pair of columns $(i,j)$
from $\sS'$, and a new pair of rows $(\lambda, \mu)$ from $\tT'$.  Then, after
fixing appropriate $\xi$ and $k$ in lines 24--25 as in Theorem
\ref{thm:linked-triple-to-pairs} condition (iii), we add the pair
$$\big((i, p_{\xi i}^{-1}np_{\lambda k}^{-1}, \lambda),
(j, p_{\xi j}^{-1}p_{\mu k}^{-1}, \mu)\big),$$
which can be seen by inspection to satisfy (i), (ii) and (iii) for the three
generators in question.

On each iteration of the while-loop, we remove one item from each of $N'$,
$\sS'$ and $\tT'$ (lines 18--23), and we add one pair to $\R$.
This is repeated until all three sets are
exhausted, and so the total number of pairs returned by the algorithm is equal
to the size of the largest of the three sets -- that is,
$$\max(|N'|, |I| - k_\sS, |\Lambda| - k_\tT).$$
If the sets have different sizes, then on some of the later runs through the
loop, one or two of the three sets will be empty.  This does not present a
problem: if a set is empty, it is not popped again and the last value from the
loop is simply used again.  The set of pairs still satisfies the necessary
condition from the theorem.  The only remaining case is that one of the sets may
be empty.  To account for this case, we give each of the three variables a
default value in lines 14--16, so that even if a set is never popped, there is a
sensible default value that does not invalidate the condition: for $a$ we can use the identity
$1_G$ which must always be in $N$; for $(i,j)$ or $(\lambda,\mu)$ we can use a
reflexive pair, from $\Delta_I$ or $\Delta_\Lambda$ respectively.

It is natural to ask whether a set of generating pairs returned by
\textsc{PairsFromLinkedTriple} is minimal -- that is, to ask whether
any smaller set of pairs could be found which generates the same congruence.

\begin{theorem}
  % More setup?
  If $|N'| \leq |I| - k_\sS$ or $|N'| \leq |\Lambda| - k_\tT$, then
  \textsc{PairsFromLinkedTriple} returns a set of generating pairs
  which is minimal.
  \begin{proof}
    The number of pairs returned by \textsc{PairsFromLinkedTriple}
    depends solely on the sizes of $N'$, $\sS'$ and $\tT'$: it is simply the
    maximum of these three sizes.  The generating set $N'$ is assumed by the
    algorithm to have been known in advance, and hence is not guaranteed to be
    minimal in any way.  However, $\sS'$ and $\tT'$ are created in the
    algorithm, each one consisting of a set of pairs in $I \times I$ or
    $\Lambda \times \Lambda$ which makes a minimal spanning tree for each class
    in the relation.  In other words, $\sS'$ and $\tT'$ contain the smallest
    possible number of pairs such that $(\sS')^e = \sS$ and $(\tT')^e = \tT$.
    Note that $|\sS'| = |I| - k_\sS$ and $|\tT'| = |\Lambda| - k_\tT$.

    Let $\R$ denote the output of the algorithm, and let $\R|_I$ be as in
    Definition \ref{def:ri}.  We can see from the definition of our algorithm
    that $\R|_I = \sS'$, and Theorem \ref{thm:pairs-to-linked-triple} tells us
    that $\sS_{\Rs} = (\R|_I)^e$; that is, we require that $(\sS')^e = \sS$ for
    the algorithm for the output $\R$ to be valid.  Since we have already seen
    that $\sS'$ has as few pairs as possible such that $(\sS')^e = \sS$, we know
    that every pair in $\sS'$ is necessary to produce a congruence with linked
    triple $(N, \sS, \tT)$.  So $|\sS'|$ is a lower bound for the
    size of a set of generating pairs for the congruence.  By similar reasoning,
    $|\tT'|$ is also a lower bound.

    Assume $|N'| \leq |I| - k_\sS$ or $|N'| \leq |\Lambda| - k_\tT|$.  The
    number of pairs returned by the algorithm will be either $|I| - k_\sS$ or
    $|\Lambda| - k_\tT$.  Since we know that these are both lower bounds for the
    possible size of a generating set, we can conclude that the size of $\R$
    equals the minimum possible size, so $\R$ is minimal.
  \end{proof}
\end{theorem}

In the case that $N'$ is larger than both $|I| - k_\sS$ and $|\Lambda| - k_\tT$,
a claim to minimality cannot be made so easily.  Again referring to Theorem
\ref{thm:pairs-to-linked-triple}, we see that whereas $\sS_{\Rs}$ and
$\tT_{\Rs}$ are determined entirely by the $I$ and $\Lambda$ parts of $\R$
respectively, the normal subgroup $N_{\Rs}$ contains elements that may be
implied by all three components of pairs in $\R$.  Indeed, it may be that some
elements in $N'$ are in fact implied to be in $N$ by some $q_{\lambda \mu i j}$,
and so could be removed from $N'$ without any loss.  Identifying which elements
are required in $N'$ and which are not could be difficult computationally, but
could be an interesting area of further research that would guarantee minimality
in all cases.
Note that, so long as $N'$, $\sS'$ and $\tT'$ are all finite, the set of pairs
is guaranteed to be finite, as is the number of steps in the algorithm.  Hence
we can be certain that the algorithm will terminate, since we can never enter an
infinite loop.

\begin{algorithm}
\caption{The \textsc{PairsFromLinkedTriple} algorithm}
\label{alg:linked-triple-to-pairs}
\index{PairsFromLinkedTriple@\textsc{PairsFromLinkedTriple}}
\begin{algorithmic}[1]
  \Procedure{PairsFromLinkedTriple}{$N, \mathcal{S}, \mathcal{T}$}
    \State $N' := $ normal subgroup generating set for $N$
    \State $\sS' := \varnothing$
    \For{each non-singleton class $\{i_1, i_2, \ldots, i_n\}$ of $\mathcal{S}$}
      \For{$l \in \{2, \ldots, n\}$}
        \State \textsc{Push} $(i_1, i_l)$ onto $\sS'$
        \LComment This will make $\sS'$ a minimal spanning forest of depth $1$ for $\sS$
      \EndFor
    \EndFor
    \State $\tT' := \varnothing$
    \For{each non-singleton class $\{\lambda_1, \lambda_2, \ldots, \lambda_n\}$ of $\mathcal{T}$}
      \For{$l \in \{2, \ldots, n\}$}
        \State \textsc{Push} $(\lambda_1, \lambda_l)$ onto $\tT'$
        \LComment This will make $\tT'$ a minimal spanning forest of depth $1$ for $\tT$
      \EndFor
    \EndFor
    \State $\R := \varnothing$
    %\State $m := \max (|N'|, |\sS'|, |\tT'|)$
    \State $a := 1_G$
    \State $(i,j) := (1,1)$
    \State $(\lambda,\mu) := (1,1)$
    \While{$N' \neq \varnothing$ \Or $\sS' \neq \varnothing$ \Or $\tT' \neq \varnothing$}
      \If{$N' \neq \varnothing$}
        \State $a \gets$ \Call{Pop}{$N'$}
      \EndIf
      \If{$\sS' \neq \varnothing$}
        \State $(i,j) \gets$ \Call{Pop}{$\sS'$}
      \EndIf
      \If{$\tT' \neq \varnothing$}
        \State $(\lambda, \mu) \gets$ \Call{Pop}{$\tT'$}
      \EndIf
      \State Fix some $\xi \in \Lambda$ such that $p_{\xi i} \neq 0$
      \State Fix some $k \in I$ such that $p_{\lambda k} \neq 0$
      \State $\R \gets \R \cup \Big\{\big(
        (i, p_{\xi i}^{-1}ap_{\lambda k}^{-1}, \lambda),
        (j, p_{\xi j}^{-1}p_{\mu k}^{-1}, \mu)
        \big)\Big\}$
    \EndWhile
    \State \Return $\R$
  \EndProcedure
\end{algorithmic}
\end{algorithm}

We can see how the algorithm performs on the following example.

\begin{example}
  \label{ex:linked-triple-to-pairs-3x4}
  Consider the semigroup
  $S = \mathcal{M}^0[\Sym_4; \{1, 2, 3\}, \{1, 2, 3, 4\};P]$ where
  $\Sym_4$ is the symmetric group of degree $4$, and $P$ is the $4 \times 3$
  matrix
  $$
  \begin{pmatrix}
    0 & 0 & (1~2)(3~4) \\
    (1~4) & () & 0 \\
    (1~3~2~4) & (2~3~4) & 0 \\
    0 & (1~4~2) & 0
  \end{pmatrix}.
  $$
  This semigroup has 8 congruences: the universal congruence $\nabla_S$, and 7
  congruences defined by linked triples -- this can be calculated slowly by hand,
  but much more quickly using the \Semigroups{} package \cite{semigroups}.  One
  such congruence is given by the linked triple $\left(\Alt_4, \Delta_3, (2,3)^e\right)$,
  where $\Alt_4$ is the alternating group of degree $4$, $\Delta_3$ is the
  diagonal relation on the column set $\{1, 2, 3\}$, and $(2,3)^e$ is the
  equivalence on the row set $\{1, 2, 3, 4\}$ which only unites rows $2$ and
  $3$.

  If we call
  \textsc{PairsFromLinkedTriple}$\left(\Alt_4, \Delta_3,
    (2,3)^e\right)$,
  the algorithm first produces the three generating components $N'$, $\sS'$ and
  $\tT'$.  The alternating group $\Alt_4$ can be generated by the set
  $\left\{(1~2~3), (2~3~4)\right\}$, so we may choose this to be our generating
  set $N'$; since $\Delta_3$ is diagonal we produce $\sS' = \varnothing$ and
  since only two rows are united by $(2,3)^e$ we produce
  $\tT' = \left\{(2,3)\right\}$.  Now we collate these three sets to make
  generating pairs for the congruence.

  For the first pair, we have $a = (1~2~3)$, the default column values of
  $(i,j)=(1,1)$, and $(\lambda,\mu)=(2,3)$.  We use the lowest possible values
  for $\xi$ and $k$: $\xi = 2$ and $k = 1$.  The pair we add is
  \begin{align*}
    \big(
      (i, p_{\xi i}^{-1}ap_{\lambda k}^{-1}, \lambda),
      (j, p_{\xi j}^{-1}p_{\mu k}^{-1}, \mu)
    \big)
    &= \big(
      (1, p_{2 1}^{-1}(1~2~3)p_{2 1}^{-1}, 2),
      (1, p_{2 1}^{-1}p_{3 1}^{-1}, 3)
    \big) \\
    &= \big(
      \left(1, (1~4)(1~2~3)(1~4), 2\right),
      \left(1, (1~4)(1~4~2~3), 3\right)
    \big) \\
    &= \big(
      \left(1, (2~3~4), 2\right),
      \left(1, (1~2~3), 3\right)
    \big).
  \end{align*}
  For the second pair, we change $a$ to the second generator $(2~3~4)$, and
  having exhausted both $\sS'$ and $\tT'$ we leave $(i,j)$ and $(\lambda,\mu)$
  unchanged.  We can use the same values for $\xi$ and $k$, so the next pair we
  add is
  \begin{align*}
    \big(
      (1, p_{2 1}^{-1}(2~3~4)p_{2 1}^{-1}, 2),
      (1, p_{2 1}^{-1}p_{3 1}^{-1}, 3)
    \big)
    &= \big(
      \left(1, (1~4)(2~3~4)(1~4), 2\right),
      \left(1, (1~4)(1~4~2~3), 3\right)
    \big) \\
    &= \big(
      \left(1, (1~2~3), 2\right),
      \left(1, (1~2~3), 3\right)
    \big).
  \end{align*}
  This exhausts $N'$ as well, so have exhausted all three sets.  We therefore
  return the set of two pairs,
  $$\Big\{
    \big(
      \left(1, (2~3~4), 2\right),
      \left(1, (1~2~3), 3\right)
    \big),
    \big(
      \left(1, (1~2~3), 2\right),
      \left(1, (1~2~3), 3\right)
    \big)
  \Big\},$$
  which is a valid generating set for the congruence.
\end{example}

\subsection{Kernel and trace from generating pairs}
\label{sec:pairs-to-kertr}

Given a set of generating pairs $\R$ over a semigroup $S$, we may wish
to consider the congruence $\rho = \R^\sharp$ and ask questions such as
whether a pair lies in the congruence, or the number of congruence classes.
This is certainly possible by various methods, for example the variety of
algorithms mentioned in Chapter \ref{chap:pairs} -- however, if $S$ is an inverse
semigroup then any calculation we wish to carry out will be much faster if we
know the congruence's kernel--trace pair, as described in Section
\ref{sec:kertr}.  We therefore wish for an algorithm that determines the kernel
and trace of $\rho$.

One way of calculating the kernel and trace would be simply to enumerate all the
elements in all the classes of $\rho$, and to search for the idempotents to
compute the kernel and trace.  However, enumerating all the classes is very
time-consuming, and the main reason to calculate the kernel--trace pair in the
first place is probably to avoid this work.  Hence, we want to find the
kernel--trace pair directly from the generating pairs $\R$, enumerating
as few pairs in $\R^\sharp$ as possible.

A new way of finding the kernel and trace directly from the generating pairs is
presented in pseudo-code in Algorithm \ref{alg:pairs-to-kertr}, which will
require some explanation.  It is based on a simple idea: firstly, populate $K$
and $\tau$ with those elements that are implied directly by the pairs in
$\R$; then, add further elements to $K$ and $\tau$ to satisfy the
conditions of a kernel--trace pair.  This means we return the least kernel--trace
pair $(K, \tau)$ that implies the pairs in $\R$ -- that is, we return
the kernel--trace pair that corresponds to $\R^\sharp$.  This idea is
explained more explicitly below.

\begin{algorithm}
\caption{The \textsc{KerTraceFromPairs} algorithm}
\label{alg:pairs-to-kertr}
\index{KerTraceFromPairs@\textsc{KerTraceFromPairs}}
\index{EnumerateKernel@\textsc{EnumerateKernel}}
\index{EnforceConditions@\textsc{EnforceConditions}}
\index{EnumerateTrace@\textsc{EnumerateTrace}}
\begin{algorithmic}[1]
\Require $S$ an inverse semigroup with idempotents $E$
\Require $\R \subseteq S \times S$
\Procedure{KerTraceFromPairs}{$\R$}
\State $K := E$
\State $\tau := \Delta_E$
\State Let $S'$ be a generating set for $S$
\State Let $E'$ be a generating set for $E$
\State $X \gets E' \cup \{ab^{-1} : (a,b) \in \R\}$
\State $\mathbf{T} \gets \{(a^{-1}a, b^{-1}b) : (a,b) \in \R\}$
\State $\tau \gets (\tau \cup \mathbf{T})^e$
\Repeat
\State $\delta \gets \False$ \Comment{Nothing has changed yet}
\State \Call{EnumerateKernel}{ }
\State \Call{EnforceConditions}{ }
\State \Call{EnumerateTrace}{ }
\Until{$\delta = \False$} \Comment{Exit loop if nothing changed}
\State \Return $(K, \tau)$
\EndProcedure

\Procedure{EnumerateKernel}{ }
\If{$X \setminus K \neq \varnothing$}
  \State $K \gets \llangle K, X \rrangle$
  \State $\delta \gets \True$
\EndIf
\State $X \gets \varnothing$
\EndProcedure

\Procedure{EnforceConditions}{ }
\For{$a \in S$}
  \If{$a \in K$}
    \If{$(aa^{-1}, a^{-1}a) \notin \tau$}
      \State $\mathbf{T} \gets \mathbf{T} \cup \{(aa^{-1}, a^{-1}a)\}$
      \State $\tau \gets \tau \cup \{(aa^{-1}, a^{-1}a)\}$
      \State $\delta \gets \True$
    \EndIf
  \Else
    \For{$e \in [a^{-1}a]_\tau$}
      \If{$ae \in K$}
        \State $X \gets X \cup \{a\}$
        \State $\delta \gets \True$
      \EndIf
    \EndFor
  \EndIf
\EndFor
\EndProcedure

\Procedure{EnumerateTrace}{ }
\While{$\mathbf{T} \neq \varnothing$}
  \State Pick any $(x,y) \in \mathbf{T}$
  \For{$e \in E'$}
    \If{$(xe, ye) \notin \tau$}
      \State $\delta \gets \True$
      \State $\mathbf{T} \gets \mathbf{T} \cup \{(xe, ye)\}$
      \State $\tau \gets (\tau \cup \{(xe, ye)\})^e$
      \For{$a \in S'$}
        % TODO? check code: should this definitely be a^-1 xe a, with the e?
        \If{$(a^{-1}xea, a^{-1}yea) \notin \tau$}
          \State $\mathbf{T} \gets \mathbf{T} \cup \{(a^{-1}xa, a^{-1}ya)\}$
          \State $\tau \gets (\tau \cup \{(a^{-1}xa, a^{-1}ya)\})^e$
        \EndIf
      \EndFor
    \EndIf
  \EndFor
  \State $\mathbf{T} \gets \mathbf{T} \setminus \{(x,y)\}$
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

% kernelgenstoapply = $X$
% pairstoapply = $\mathbf{T}$
% traceBlocks/traceUF = $\tau$

To understand why the algorithm is correct, we make use of the following lemma,
akin to Lemma \ref{lem:linked-triple-subsets} for linked triples.

\begin{lemma}
  \label{lem:kertr-subsets}
  Let $\rho$ and $\sigma$ be congruences on $S$ with kernel--trace pairs
  $(K_\rho, \tau_\rho)$ and $(K_\sigma, \tau_\sigma)$ respectively.  We have
  $\rho \subseteq \sigma$ if and only if $K_\rho \leq K_\sigma$ and
  $\tau_\rho \subseteq \tau_\sigma$.
  \begin{proof}
    Assume $K_\rho \leq K_\sigma$ and $\tau_\rho \subseteq \tau_\sigma$, and let
    $(x,y) \in \rho$.  By Theorem \ref{thm:kernel-trace-pair}, we have
    $xy^{-1} \in K_\rho$ and $(x^{-1}x, y^{-1}y) \in \tau_\rho$.  Hence
    $xy^{-1} \in K_\sigma$ and $(x^{-1}x, y^{-1}y) \in \tau_\sigma$, which
    together imply $(x,y) \in \sigma$.  Hence $\rho \subseteq \sigma$.

    Conversely, assume $\rho \subseteq \sigma$.  If $k \in K_\rho$ then
    $k=xy^{-1}$ for some $(x,y) \in \rho$; this means $(x,y) \in \sigma$, so
    $k=xy^{-1} \in K_\sigma$.  Similarly, if $(e,f) \in \tau_\rho$ then
    $(e,f) = (x^{-1}x, y^{-1}y)$ for some $(x,y) \in \rho$; this means
    $(x,y) \in \sigma$, so $(e,f) = (x^{-1}x, y^{-1}y) \in \tau_\sigma$.  Hence
    $K_\rho \leq K_\sigma$ and $\tau_\rho \subseteq \tau_\sigma$, as
    required.
  \end{proof}
\end{lemma}

The kernel $K$ starts out containing just the idempotents $E$ (line 2), and the trace
$\tau$ starts out as the trivial congruence on $E$ (line 3).  Every kernel and trace must
contain at least these elements -- in fact, after line 3, $(K, \tau)$ corresponds to
the trivial congruence $\Delta_S$.  We assume that we have generating sets $S'$
for $S$ and $E'$ for $E$ (lines 4--5).  In the worst case, we can use $S$ and $E$ themselves,
but the algorithm is likely to run faster with a smaller generating set.
Certainly in computational settings such as the \Semigroups{} package for \GAP{}
\cite{semigroups} semigroups such as $S$ and $E$ have a generating set stored,
and a smaller generating set can sometimes be created by eliminating unnecessary
elements.

Once these setup steps have been done, we add information from the known pairs
of $\rho$ -- that is, from the pairs in $\R$.  Theorem
\ref{thm:kernel-trace-pair} tells us that a pair $(a,b)$ lies in $\rho$ if and
only if $ab^{-1} \in K$ and $(a^{-1}a, b^{-1}b) \in \tau$.  Now instead of using
$K$ and $\tau$ to determine whether a pair is in $\rho$, we are using a pair in
$\rho$ to impose conditions on $K$ and $\tau$.  We have two sets, $X$ and
$\mathbf{T}$, which act as queues for elements that need to be processed in $K$
and $\tau$ respectively.  For each $(a,b) \in \R$ we put $ab^{-1}$ into
$X$ (line 6) and $(a^{-1}a, b^{-1}b)$ into $\mathbf{T}$ (line 7); elements in $X$ will be added
to $K$ next time we call \textsc{EnumerateKernel}, and we add $\mathbf{T}$ to
$\tau$ straight away (line 8).

Once this has been done, the rule that $(a,b)$ lies in $\rho$ if and only if
$ab^{-1} \in K$ and $(a^{-1}a, b^{-1}b) \in \tau$ is satisfied for all pairs
$(a,b) \in \R$.  All that is left to do is to add any elements to $K$
and pairs to $\tau$ required to make $(K, \tau)$ a kernel--trace pair.  The rest
of the algorithm (lines 9--15 and the three sub-procedures) focuses on this task.

Recall from Definitions \ref{def:kernel-normal}, \ref{def:trace-normal} and
\ref{def:kernel-trace-pair} the conditions for a kernel--trace pair.  We require
$(K, \tau)$ to satisfy these conditions, and we must make any additions
necessary until they are all fulfilled.  For this purpose we have three
sub-procedures -- \textsc{EnumerateKernel}, \textsc{EnumerateTrace}, and
\textsc{EnforceConditions} -- that test the conditions for a kernel--trace pair
and add any elements necessary.  Any of these methods might add to $K$ or
$\tau$, which might in turn imply that another method has more information to
find.  Hence, the three methods are run repeatedly until an entire run is
completed in which no new information is found ($\delta$ remains false
throughout the entire run).  If no new information is found,
$(K, \tau)$ is guaranteed to be a kernel--trace pair, and we can return.  The
three methods could be run in any order without the correctness of the algorithm
being affected, but the order shown in Algorithm \ref{alg:pairs-to-kertr} seems
to have the best time performance, based on informal experiments.  All three
methods are considered to have access to any of the variables in the overall
algorithm.

The first method, \textsc{EnumerateKernel}, first checks whether there are any
new elements in $X$ that have not already been added to $K$ (line 17).  If there
are, it adds all the elements from $X$ to $K$, and then on line 18 it adds any
necessary elements to $K$ to ensure that it is self-conjugate in the sense of
Definition \ref{def:kernel-normal} (this is denoted with the notation
$\llangle \cdot \rrangle$).  Since $K$ starts containing $E$, this is enough to
guarantee that $K$ is a normal subsemigroup, a fact we can be certain of at the
end of \textsc{EnumerateKernel}.  If a change was made, we set $\delta$ to true,
and in any case we empty the set $X$ to indicate that no new elements have been
found since this sub-procedure was run.

The \textsc{EnumerateTrace} method ensures that $\tau$ is a normal congruence
(see Definition \ref{def:trace-normal}).  It considers all the pairs that have
been added to $\tau$ since the last call to \textsc{EnumerateTrace} -- these are
precisely the pairs in $\mathbf{T}$ -- and makes sure that any pairs implied by
them are added to $\tau$ and $\mathbf{T}$.  For each $(x,y) \in \mathbf{T}$, the
left and right multiples of $(x,y)$ must be in $\tau$ (as required by the
definition of a congruence).  In fact, only the right-multiples $(xe, ye)$ need
to be added, since idempotents commute in an inverse semigroup, and the trace is
only a relation on the idempotents.  If any of these
pairs are new, they are added to $\mathbf{T}$ so that further multiples can be
found; this is why we only need to multiply by the generators from $E'$, rather
than all elements in $E$.
So, in \textsc{EnumerateTrace}, we go through all the pairs $(x,y)$ in
$\mathbf{T}$ one at a time (lines 34--35) and apply each generator $e \in E'$ to
its right-hand side to make the pair $(xe, ye)$ (lines 36--37), which is equal
to $(ex, ey)$ by commutativity.  For each one of these pairs that is not already
in $\tau$, we have to add it to $\tau$ to ensure that $\tau$ remains a
congruence (line 40), and we have to add it to $\mathbf{T}$ (line 39) to ensure
that we process all of its right-multiples in a future iteration of the
while-loop.  In order to ensure that $\tau$ is normal, we also need to conjugate
the pair by each generator of the semigroup $a$, and add any of these to $\tau$
and $\mathbf{T}$ if they are not already present (lines 41--44).  At the end of
a call to \textsc{EnumerateTrace}, we can thus be sure that $\tau$ is a normal
congruence.  If any changes are made in this call to \textsc{EnumerateTrace},
then we must of course set $\delta$ to true (line 38).
% TODO: a-1xa, a-1ya should be a-1xea, a-1yea ?

Finally, \textsc{EnforceConditions} deals with conditions (i) and (ii) from
Definition \ref{def:kernel-trace-pair}.  It adds any necessary elements to $X$
and any necessary pairs to $\mathbf{T}$ and $\tau$, and when finished,
$(K,\tau)$ is guaranteed to satisfy conditions (i) and (ii), at least on a run
in which the other two methods make no changes.  To achieve this, we iterate
through each element $a$ in the semigroup (line 22).  If $a$ is in the kernel
$K$ (line 23), then we need to ensure that $(aa^{-1}, a^{-1}a)$ is in the trace
$\tau$ to enforce condition (ii); we add it if necessary (lines 24--26).  If $a$
is not in the kernel $K$ but $ae \in K$ and $(e, a^{-1}a) \in \tau$ for some
idempotent $e$, then we need to add $a$ to the kernel in order to satisfy
condition (i).  Hence, if $a$ is not in the kernel (line 28), we check any
idempotents $e$ that are $\tau$-related to $a^{-1}a$ (line 29), and if $ae$ is
in the kernel (line 30) then we add $a$ to the list $X$ of elements to be added
to the kernel in the next run of \textsc{EnumerateKernel} (line 31).  If we make
any changes to $\mathbf{T}$ or $X$ in this procedure, we again set $\delta$ to
true (lines 27 and 32).

If all three methods complete without any new information being found, they will
have acted as a test ensuring that
$K$ is a normal subsemigroup of $S$, that $\tau$ is a normal congruence on $E$,
and that the two conditions in Definition \ref{def:kernel-trace-pair} are
satisfied; in other words, that $(K, \tau)$ is a valid kernel--trace pair.
This means that $(K, \tau)$ corresponds to a congruence $(K,\tau)\Psi^{-1}$, and
we know that this congruence contains every pair in $\R$.  Hence
$\R^\sharp \subseteq (K,\tau)\Psi^{-1}$.  Since we did not add any
elements to $K$ or $\tau$ except those implied by $\R$ or those required
by the definition of a kernel--trace pair, we can also be sure that
$(K, \tau)\Psi^{-1} \subseteq \R^\sharp$, by Lemma
\ref{lem:kertr-subsets}.  Hence $(K, \tau)$ is the kernel--trace pair
corresponding to the congruence $\R^\sharp$.

Note that, so long as $S$ is finite, the \textsc{KerTraceFromPairs} algorithm is
guaranteed to complete in finite time.  Due to the way $\delta$ is set, the
repeat-loop can only continue so long as the last iteration of the loop added
something new to $K$ or $\tau$.  Since $K$ can only contain elements from $S$
and $\tau$ can only contain elements from $E \times E$, we therefore have an
upper bound of $|K| + |E|^2$ times that the loop can be executed, and the likely
number of times it will be executed is much lower.  Similarly, there are no
loops inside any of the sub-procedures that can run indefinitely.  Hence the
algorithm is certain to terminate and return an answer eventually.

\subsection{Kernel and trace of a Rees congruence}
\label{sec:rees-to-kertr}
Let $S$ be an inverse semigroup with idempotents $E$.  Each congruence on $S$ is
defined by its kernel and trace (see Section \ref{sec:kertr}), and some
congruences on $S$ may be Rees (see Section \ref{sec:converting-rees}).  We may wish
to find the kernel and trace of a Rees congruence given the ideal that defines
it.  Conversely, we may wish to determine whether a given kernel--trace pair on
$S$ describes a Rees congruence, and if so, what ideal it is associated with.

Let $I$ be an ideal in $S$, and let $\rho_I$ be $(I \times I) \cup \Delta_S$,
the Rees congruence corresponding to $I$.  To find the kernel and trace of
$\rho_I$ we must consider the positions of the idempotents in $S$, and how they
interact with $I$.

Since $I$ is an ideal, it must be a non-empty union of $\JJ$-classes, and since $S$ is
inverse, it has an idempotent in every $\JJ$-class; hence, there is at least one
idempotent in $I$.  The kernel of $\rho_I$ is defined as the set of all elements
which are related to an idempotent -- that is, all elements in $I$ and all
idempotents outside $I$.  Hence $\ker \rho_I = E \cup I$.  The trace of $\rho_I$
is defined as the restriction of $\rho_I$ to the idempotents.  Two distinct
idempotents are $\rho_I$-related if and only if they both lie in $I$; hence
$\tr \rho_I = \left((E \cap I) \times (E \cap I)\right) \cup \Delta_E$.

Now we turn our attention to the other direction.  Let $\rho$ be a congruence
defined by a kernel--trace pair $(K, \tau)$.  How can we determine directly from
$K$ and $\tau$ whether $\rho$ is a Rees congruence?  We first prove a lemma, and
then go on to answer this question.

\begin{lemma}
  \label{lem:xly}
  Let $x$ and $y$ be elements of an inverse semigroup $S$.  If $xy^{-1}$ is
  idempotent and $x^{-1}x = y^{-1}y$, then $x = y$.
  \begin{proof}
    We start by proving that $xy^{-1} = yy^{-1}$, and then go on to prove that
    $x=y$.  By Proposition \ref{prop:inverse-semigroup-facts}(i), we know that
    $yy^{-1}$ is idempotent.  We can left-multiply each of $xy^{-1}$ and
    $yy^{-1}$ by an element in $S$ to give the other:
    $yx^{-1}(xy^{-1}) = y(x^{-1}x)y^{-1} = yy^{-1}yy^{-1} = yy^{-1}$ and
    $xy^{-1}(yy^{-1}) = xy^{-1}$.  Hence $xy^{-1} \LL yy^{-1}$.  However, we
    know from Proposition \ref{prop:inverse-semigroup-facts}(ii) that an inverse
    semigroup has only one idempotent in each $\LL$-class.  Since $xy^{-1}$ and
    $yy^{-1}$ are both idempotent, we must therefore conclude that
    $xy^{-1} = yy^{-1}$.  Finally, we observe that
    $$x = x(x^{-1}x) = x(y^{-1}y) = (xy^{-1})y = (yy^{-1})y = y,$$
    and so we have $x=y$ as required.
  \end{proof}
\end{lemma}

\begin{theorem}
  \label{thm:kertr-to-rees}
  Let $S$ be an inverse semigroup with set of idempotents $E$.  If $(K, \tau)$
  is a kernel--trace pair on $S$, then the congruence it defines is a Rees
  congruence if and only if the following hold:
  \begin{enumerate}[\rm(i)]
  \item $\tau$ is a Rees congruence on $E$, with ideal denoted by $I_\tau$;
  \item $K = S I_\tau S \cup E$.
  \end{enumerate}
  \begin{proof}
    Recall that $SXS = S^1XS^1$ for any set $X \subseteq S$, since
    $x(x^{-1}x)=(xx^{-1})x=x$ for any $x$ in an inverse semigroup.

    Let $\rho$ be the congruence defined by $(K, \tau)$.  We will first show
    that (i) and (ii) imply that $\rho$ is Rees, and then we will show that
    $\rho$ being Rees implies (i) and (ii).

    First, assume that (i) and (ii) hold.  Let $I = S I_\tau S$, so that
    $K = I \cup E$.  This $I$ is closed under left and right multiplication, so
    it is certainly an ideal of $S$.  We will show that $\rho$ is equal to the
    Rees congruence $\rho_I$, by showing $\rho_I \subseteq \rho$ and
    $\rho \subseteq \rho_I$.

    For the first, let $(x,y) \in \rho_I$.  If $x=y$ then $(x,y) \in \rho$ by
    reflexivity.  Otherwise $x$ and $y$ are both in $I$, so $x = aeb$ and
    $y=cfd$ for some $e,f \in I_\tau$ and $a,b,c,d \in S$.  Since $I$ is an
    ideal and $x \in I$, we have $xy^{-1} \in I$ and therefore $xy^{-1} \in K$.
    Meanwhile we have $x^{-1}x = (aeb)^{-1}(aeb) = b^{-1}ea^{-1}aeb$: since
    $a^{-1}a$ and $e$ are both idempotents, $ea^{-1}ae$ is an idempotent, and
    since $e \in I_\tau$ we also have $ea^{-1}ae \in I_\tau$; finally, since
    $I_\tau$ is normal (see Definition \ref{def:trace-normal}) we have
    $b^{-1}(ea^{-1}ae)b \in I_\tau$, and so $x^{-1}x \in I_\tau$.  Similarly
    $y^{-1}y \in I_\tau$, so $(x^{-1}x, y^{-1}y) \in \tau$.  Since
    $xy^{-1} \in K$ and $(x^{-1}x, y^{-1}y) \in \tau$, we have $(x,y) \in \rho$
    by Theorem \ref{thm:kernel-trace-pair}.

    For the second, let $(x,y) \in \rho$.  By Theorem
    \ref{thm:kernel-trace-pair} we have $xy^{-1} \in K = I \cup E$ and
    $(x^{-1}x, y^{-1}y) \in \tau$: either $x^{-1}x=y^{-1}y$, or
    $x^{-1}x,y^{-1}y \in I_\tau$.  If $x^{-1}x = y^{-1}y$, then $x \LL y$; we
    also have $(xy^{-1})y = xx^{-1}x = x$, so $x \RR xy^{-1}$.  Now, since
    $\lL \subseteq \jJ$ and $\rR \subseteq \jJ$, we know that $x$, $y$ and
    $xy^{-1}$ are all $\JJ$-related, so we have $x,y \in I$ in the case that
    $xy^{-1} \in I$.  In the case that $xy^{-1} \in E$, we must have $x=y$ by
    Lemma \ref{lem:xly}.  Either way, $(x,y) \in \rho_I$.  Alternatively, if
    $x^{-1}x, y^{-1}y \in I_\tau$, then since $x \JJ x^{-1}x$ and
    $y \JJ y^{-1}y$, we have $x,y \in SI_\tau S$, that is $x,y \in I$ and so
    $(x,y) \in \rho_I$.  So $(x,y) \in \rho$ implies $\rho_I$, as required.
    Hence $\rho = \rho_I$, so $\rho$ is Rees.

    We now wish to show the converse, that $\rho$ being Rees implies (i) and
    (ii).  Assume $\rho$ is a Rees congruence with ideal $I$, and let $(K,\tau)$
    be its kernel--trace pair.  The trace $\tau$ of $\rho$ is the restriction of
    $\rho$ to the idempotents $E$; this is easily seen to be a Rees congruence
    on $E$ with ideal $I \cap E$.  This gives us (i), where $I_\tau = I \cap E$.
    The kernel $K$ of $\rho$ is the set of elements $\rho$-congruent to an
    idempotent: this gives us $K = I \cup E$, since $K$ consists of every
    element in the ideal $I$ along with any other idempotents.  Since any ideal
    is a union of $\JJ$-classes, and since any $\JJ$-class in an inverse
    semigroup contains an idempotent, we know that $I$ is equal to
    $S(I \cap E)S$, which is equal to $S I_\tau S$.  Hence
    $K = S I_\tau S \cup E$, and so we have (ii).
  \end{proof}
\end{theorem}

\subsection{Trivial conversions}
\label{sec:trivial-conversions}
Some of the conversions between different representations are particularly
trivial in nature, requiring almost no computational resources to calculate.
However, it is worth mentioning them here for completeness.

\subsubsection{Normal subgroups and kernel--trace pairs}
All groups are inverse semigroups.  Hence, if we have a congruence on a group,
it can be represented by a normal subgroup or by a kernel--trace pair.  Let
$\rho$ be such a congruence, on a group $G$: the classes of $\rho$ are the
cosets of some normal subgroup $N$.  The kernel of $\rho$ is defined as the set
of elements which are $\rho$-related to an idempotent.  Since there is only one
idempotent -- the identity $1_G$ -- the kernel is all the elements in $N$.  The
trace of $\rho$ is defined as the restriction of $\rho$ to the idempotent; so
$\tr\rho$ is just the trivial equivalence on the single element $1_G$.  Hence a
congruence with normal subgroup $N$ has kernel--trace pair
$(N, \Delta_{\{1_G\}})$.

\subsubsection{Normal subgroups and Rees congruences}
A group $G$ has precisely one Rees congruence: the universal congruence
$\rho_G$.  Its normal subgroup is the entire group $G$.

\subsubsection{Linked triples and Rees congruences}
A completely 0-simple semigroup $\mathcal{M}^0[G;I,\Lambda;P]$ (over a group $G$
and regular matrix $P$) has two Rees
congruences: the universal congruence and the trivial congruence.  The universal
congruence has no linked triple, while the trivial congruence corresponds to the
linked triple $(\{1_G\}, \Delta_I, \Delta_\Lambda)$.  A completely simple
semigroup $\mathcal{M}[G;I,\Lambda;P]$ has only one Rees congruence: the
universal congruence, which has linked triple $(G, \nabla_I, \nabla_\Lambda)$.

\subsubsection{Linked triples and kernel--trace pairs}
We may wish to convert between linked triples and kernel--trace pairs, in the
case of an inverse semigroup which is completely simple or completely 0-simple.
An inverse semigroup has exactly one idempotent in each $\LL$-class and each
$\RR$-class, while a simple semigroup has just one $\DD$-class and an idempotent
in every $\HH$-class.  Hence a completely simple inverse semigroup has just one
$\HH$-class, and since it contains an idempotent it must be a group.  Since it
is a group, we can conclude that any congruence on a completely simple inverse
semigroup has a linked triple of the form $(N, \Delta_I, \Delta_\Lambda)$ (see
Section \ref{sec:normal-subgroup-to-linked-triple}) which corresponds to the
kernel--trace pair $(N, \Delta_{\{1_G\}})$ (see \textit{Normal subgroups and
  kernel--trace pairs} in this section).

A completely 0-simple inverse semigroup is somewhat different, but also
uncomplicated.  Let $S$ be such a semigroup, with idempotent set $E$.  Since
each $\LL$-class and each $\RR$-class has precisely one idempotent, the
relations $\varepsilon_I$ and $\varepsilon_\Lambda$ are both trivial, so the
non-universal congruences on $S$ correspond to triples of the form
$(N, \Delta_I, \Delta_\Lambda)$ for any normal subgroup $N \trianglelefteq G$.
Now, the triviality of $\Delta_I$ and $\Delta_\Lambda$ implies that no two
elements can be related by a non-universal congruence $\rho$ unless they lie
inside the same $\HH$-class.  Hence no two idempotents are related, so
$\tr \rho = \Delta_E$.  The kernel consists of all elements in $S$ related to an
idempotent.  Idempotents are either $0$ or have the form
$(i, p_{\lambda i}^{-1}, \lambda)$ where $p_{\lambda i} \neq 0$, so non-zero
elements in the kernel must have the form $(i, a, \lambda)$ for
$p_{\lambda i} \neq 0$.  For
$(i, a, \lambda) ~\rho~ (i, p_{\lambda i}^{-1}, \lambda)$ we just need
$(p_{\xi i} a p_{\lambda x}) (p_{\xi i} p_{\lambda i}^{-1} p_{\lambda x})^{-1}
\in N$
for appropriate $\xi$ and $x$ as in Definition \ref{def:linked-triple-function};
but since each $\LL$-class and $\RR$-class contains just one idempotent, the
only possible values are $x=i$ and $\xi=\lambda$.  So the actual condition is
$(p_{\lambda i} a p_{\lambda i}) (p_{\lambda i} p_{\lambda i}^{-1} p_{\lambda
  i})^{-1} \in N$,
which is the same as $p_{\lambda i} a p_{\lambda i} p_{\lambda i}^{-1} \in N$,
or just $p_{\lambda i} a \in N$.  Hence the kernel is given by
$$\ker \rho =
\{(i, p_{\lambda i}n, \lambda) \in S ~|~ p_{\lambda i} \neq 0, n \in N\}
\cup \{0\}.$$

\subsubsection{Generating pairs and normal subgroups}
If $G$ is a group, then a congruence on $G$ can be defined either by a set of
generating pairs, or by a normal subgroup $N$.  We may wish to convert from one
of these representations to the other.  We start with a proposition for
converting a normal subgroup to a set of generating pairs.

\begin{proposition}
  \label{prop:normal-subgroup-to-genpairs}
  Let $G$ be a group, and $N$ be a normal subgroup of $G$.  If $N'$ is a
  normal subgroup generating set for $N$, then $\{(1_G, n) : n \in N'\}^\sharp$
  is the congruence on $G$ defined by $N$.
  \begin{proof}
    Let $\rho = \{(1_G, n) : n \in N'\}^\sharp$, and let $\rho_N$ be the
    congruence whose classes are the cosets of $N$.  Certainly $\rho$ is a
    congruence on $G$, so by Theorem \ref{thm:normal-subgroups} we know that
    $[1_G]_\rho$, the $\rho$-class containing the identity, is a normal subgroup
    of $G$.  This $\rho$-class contains all the elements in $N'$, so we must
    have $N \subseteq [1_G]_\rho$; and since the pairs used to generate $\rho$
    were all from $\rho_N$, we must also have $[1_G]_\rho \subseteq N$.  Hence
    the congruence classes of $\rho$ are the cosets of $N$, as required.
  \end{proof}
\end{proposition}

We also have a proposition for converting a set of generating pairs to a normal
subgroup.

\begin{proposition}
  \label{prop:genpairs-to-normal-subgroup}
  Let $G$ be a group, and $\R \subseteq G \times G$.  The normal subgroup
  generated by $\{xy^{-1} : (x,y) \in \R\}$ has cosets equal to the classes of
  the congruence $\Rs$.
  \begin{proof}
    Let $N' = \{xy^{-1} : (x,y) \in \R\}$, let $N = \llangle N' \rrangle$, and
    let $\rho_N$ be the congruence whose classes are the cosets of $N$.  If
    $(x,y) \in \R$, then $xy^{-1} \in N$, which implies $Nx=Ny$, so that
    $(x,y) \in \rho_N$; hence $\R \subseteq \rho_N$.  Since $\Rs$ is the least
    possible congruence containing $R$, we must have $\Rs \subseteq \rho_N$.
    And since $N$ contains only elements that are required by $\R$ or by the
    definition of a normal subgroup, we must also have $\rho_N \subseteq \Rs$.
    Hence $\rho_N = \Rs$, as required.
  \end{proof}
\end{proposition}

\section{Further work}
\label{sec:converting-further-work}

In this chapter we have given a survey of five different representations of
congruences, and shown some algorithms to convert one to another without
enumerating entire congruences.  Table \ref{tab:converting} shows these five
representations, and gives references to various conversions between them.
However, there are more areas of research which could be investigated, both in
creating new representations, and in creating new algorithms to convert from one
to another.

\subsection{Generating pairs from a kernel--trace pair}
\label{sec:kertr-to-pairs}
Given an inverse semigroup $S$ and a congruence $\rho$ defined by a kernel--trace
pair $(K, \tau)$, it is natural to wish for a set of generating pairs for
$\rho$.  There is not yet an algorithm to produce a set of generating pairs
directly from a kernel--trace pair, but this would be an interesting area of
future research.

A solution to this problem might follow the same structure as
\textsc{PairsFromLinkedTriple} (Algorithm
\ref{alg:linked-triple-to-pairs}): break down the problem into a component for
$K$ and a component for $\tau$, establishing a small set of elements which
generate $K$ as a normal subsemigroup of $S$, and a small set of pairs which
generate $\tau$ as a normal congruence on $E$, and somehow combining these sets
to find a set of generating pairs.

One could use the definitions of kernel and trace to produce a relatively
straightforward algorithm.  The kernel is the set of elements which are
$\rho$-congruent to an idempotent.  Hence, if $K'$ is a generating set for $K$,
then adding $(k,e)$ for each $k \in K'$, where $e$ is some idempotent such that
$k ~\rho~ e$, would ensure that the kernel contains $K$.  The trace is the
restriction of $\rho$ to the idempotents; hence, if $\tau'$ is a spanning forest
for $\tau$ so that $(\tau')^e = \tau$, adding all the pairs from $\tau'$ would
ensure that the trace contains $\tau$.  This approach would result in a very
large generating set, and could almost certainly be improved in some ways,
particularly by exploiting (i) and (ii) in Definition \ref{def:kernel-trace-pair}
of a kernel--trace pair.

\subsection{Rees congruences from generating pairs}
\label{sec:pairs-to-rees}
Given a semigroup $S$ and a set $\R \subseteq S \times S$, we may wish to know
whether the generated congruence $\Rs$ is a Rees congruence.  A method exists
for this in the \Semigroups{} package \cite{semigroups}.  It finds the congruence
classes of $\Rs$ and examines their sizes: if all classes are singletons, then
$\Rs$ is Rees if and only if a zero element exists, and if so, the ideal is
$\{0\}$; otherwise, we check that there is only one non-trivial class, and if
there is, then we check that it is an ideal.  This method works, but of course
involves enumerating the classes first.

It would be desirable to have an algorithm which can inspect the pairs in $\R$
and decide whether $\Rs$ is Rees, while doing as little calculation of the
congruence as possible.  If it is somehow determined that $\Rs$ is Rees, then it
is the Rees congruence corresponding to the ideal
$$S\{x,y \in S : (x,y) \in \R \setminus \Delta_S\}S.$$
However, it may be that an answer cannot be determined without a large amount of
work being done first.  A more achievable aim would be to find some quick tests
which could determine that $\Rs$ is or is not Rees in limited cases.  For
example, if $S$ is the Motzkin monoid $\mathcal{M}_n$, then $\Rs$ is certainly
Rees if any pair in $\R \setminus \Delta_S$ contains an element of rank greater
than $1$, by Theorem \ref{thm:mn-congs}.  Recognising many special cases
like this would make it possible for a computer package to avoid enumerating
certain congruences, which is desirable.

\subsection{Regular semigroups}
\label{sec:converting-regular}
Recall that a regular semigroup \index{regular!semigroup} is one in which every
element $x$ has an element $x'$ such that $x = xx'x$.  An inverse semigroup is a
regular semigroup in which each element has a unique such element $x^{-1}$, with
the additional requirement that $x^{-1}xx^{-1}=x^{-1}$.  In Section
\ref{sec:kertr} we discussed how a congruence on an inverse semigroup is
uniquely determined by its kernel and trace, and gave both an abstract
characterisation of a kernel--trace pair (Definition
\ref{def:kernel-trace-pair}) and a concise description of how this pair
describes its congruence ($\Psi^{-1}$ in Theorem \ref{thm:kernel-trace-pair}).
It turns out that the congruences on a regular semigroup can be described in a
similar way, which we will briefly examine here.

A congruence on a regular semigroup is uniquely determined by its kernel and
trace \cite[Corollary 2.11]{pastijn_1986}, and a kernel--trace pair can be
characterised in the following way, analogous to Definition
\ref{def:kernel-trace-pair}.  Recall the definition of $\mathbf{E}^\flat$
(Definition \ref{def:e-flat}).

\begin{definition}[{\cite[Definition 2.12]{pastijn_1986}}]
  \label{def:regular-kernel-trace-pair}
  \index{kernel--trace pair!for regular semigroups}
  A \textbf{kernel--trace pair} on a regular semigroup $S$ is a pair $(K,\tau)$
  such that the following hold:
  \begin{enumerate}[\rm(i)]
  \item $K \subseteq S$ and $K = \ker \pi_K$;
  \item $\tau$ is an equivalence on $E$ such that $\tau = \tr(\tau^\sharp)$;
  \item
    $K \subseteq \ker(\LL\mathrel{\tau}\LL\mathrel{\tau}\LL \cap
    \RR\mathrel{\tau}\RR\mathrel{\tau}\RR)^\flat$;
  \item $\tau \subseteq \tr \pi_K$;
  \end{enumerate}
  where
  $\pi_K = \left\{(a,b) \in S \times S : xay \in K \Leftrightarrow xby \in K
    \quad (x,y \in S^1)\right\}$.
\end{definition}

We even have a description of how a kernel--trace pair describes its congruence,
analogue to Theorem \ref{thm:kernel-trace-pair}.

\begin{theorem}[{\cite[Theorem 2.13]{pastijn_1986}}]
  \label{thm:regular-kernel-trace-pair}
  Let $S$ be a regular semigroup.  There exists a bijection $\Psi$ from the
  congruences on $S$ to the kernel--trace pairs on $S$, defined by
  $$\Psi: \rho \mapsto (\ker\rho, \tr\rho),$$
  and its inverse satisfies
  $$\Psi^{-1} : (K,\tau) \mapsto \pi_K \cap
  (\LL\mathrel{\tau}\LL\mathrel{\tau}\LL \cap
  \RR\mathrel{\tau}\RR\mathrel{\tau}\RR)^\flat.$$
\end{theorem}

This characterisation of congruences on regular semigroups falls short of its
inverse semigroup counterpart.  Firstly, this broader definition of a
kernel--trace pair is a lot more complicated and harder to compute with: for
example, calculating $\pi_K$ could be computationally difficult, as could
verifying (iii) and (iv) in Definition \ref{def:regular-kernel-trace-pair}.  It is
certainly difficult to contemplate any analogue of \textsc{KerTraceFromPairs}
(Algorithm \ref{alg:pairs-to-kertr}) which could find the least kernel--trace
pair from a set of generating pairs in anything like as quick a time or as
simple a procedure as in the inverse semigroup case.  Secondly, the result in
Theorem \ref{thm:regular-kernel-trace-pair} is not as convenient as the inverse
semigroup version (Theorem \ref{thm:kernel-trace-pair}): if the kernel--trace
pair of an inverse semigroup congruence is known, checking the presence of a
given pair $(x,y)$ is as simple as looking up one easily computed element in the
kernel, and looking up another easily computed pair in the trace.  In the
regular semigroup case, checking whether a pair lies in
$\pi_K \cap (\LL\mathrel{\tau}\LL\mathrel{\tau}\LL \cap
\RR\mathrel{\tau}\RR\mathrel{\tau}\RR)^\flat$ does not appear to be anything
like as easy or quick.

For these reasons, using the kernel--trace approach for regular semigroups is not
nearly as attractive as using it for inverse semigroups.  However, it is
possible that using the representation in a computational way would be feasible,
and it is possible that in some cases it would be preferable to the na\"{i}ve
use of generating pairs.  An algorithm to check the presence of a pair in
$(K,\tau)\Psi^{-1}$ given a kernel--trace pair $(K,\tau)$ would be the first
requirement; then a version of \textsc{KerTraceFromPairs} would be highly
desirable, since it would allow us to use this approach even when the kernel and
trace of a congruence are not known in advance, without enumerating the entire
congruence first.
