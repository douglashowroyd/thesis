\chapter{Converting between different congruence representations}
\label{chap:converting}

A congruence is a binary relation, and therefore is formally described as a set
of pairs---a subset of $S \times S$.  In both computational and mathematical
settings, it is worth thinking about how a congruence could be stored.

One approach to storing a congruence $\rho$ on a semigroup $S$ is simply to
store every one of its pairs.  In principle, it is possible to store
$\rho$ in this way if and only if $S$ is finite.  However, this could well use a
lot of storage---even the trivial congruence would use $O(|S|)$ space, and in
general a congruence could even use $O(|S|^2)$ space.

% TODO: reference to "most congs don't need many generating pairs" section
In Chapter \ref{chap:pairs} we looked in detail at how a congruence can be
represented by a set of generating pairs.  As we found there, a congruence can
be described by a subset $\R \subseteq \rho$, which in many cases can be
very small.  This is one very generic way of representing congruences, in two
senses: firstly that it can be used for any finite semigroup; and secondly that
it can be used for left and right congruences.

However, there are other ways to view congruences in certain circumstances: some
semigroups have properties such as being an inverse semigroup or being a group,
which allow additional things to be said about their congruences; and some
specific congruences have special properties, such as being Rees, which allows
them to be represented in a certain way.  In this chapter, we will describe some
important ways of representing congruences, and then consider ways of converting
one to another.  Section numbers for the different representations and the ways
they can be converted to one another are summarised in Table
\ref{tab:converting}.

\begin{table}[h]
  \centering
  \renewcommand{\arraystretch}{1.3}
  \begin{tabular}{ r | r | c | c | c | c | c |}
    \multicolumn{7}{c}{\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad \ldots to \ldots} \\
    \cline{2-7}
    \multirow{7}{*}{\rotatebox[origin=c]{90}{From\ldots}} &  & GP & NS & LT & KT & RC \\
    \cline{2-7}
    & Generating pairs (\ref{sec:converting-pairs}) & \cellcolor{gray} &  & \ref{sec:pairs-to-linked-triple} & \ref{sec:pairs-to-kertr} & \\
    \cline{2-7}
    & Normal subgroup (groups) (\ref{sec:normal-subgroups}) &  & \cellcolor{gray} & \ref{sec:normal-subgroup-to-linked-triple} & \ref{sec:trivial-conversions} & \ref{sec:trivial-conversions}\\
    \cline{2-7}
    & Linked triple ((0-)simple) (\ref{sec:linked-triples}) & \ref{sec:linked-triple-to-pairs} & \ref{sec:normal-subgroup-to-linked-triple} & \cellcolor{gray} & \ref{sec:trivial-conversions} & \ref{sec:trivial-conversions} \\
    \cline{2-7}
    & Kernel-trace (inverse) (\ref{sec:kertr}) &  & \ref{sec:trivial-conversions} & \ref{sec:trivial-conversions} & \cellcolor{gray} &\\
    \cline{2-7}
    & Rees congruence (\ref{sec:converting-rees}) & \ref{sec:rees-to-pairs} & \ref{sec:trivial-conversions} & \ref{sec:trivial-conversions} &  & \cellcolor{gray}\\
    \cline{2-7}
  \end{tabular}
  \renewcommand{\arraystretch}{0.7}
  \caption{Algorithms to convert between different congruence representations}
  \label{tab:converting}
\end{table}

\section{Ways of representing a congruence}
\label{sec:ways-of-representing}

We will begin by describing several different ways of representing a congruence.
These representations all exist in some form in GAP \cite{gap} or the Semigroups
package \cite{semigroups}.

\subsection{Generating pairs}
\label{sec:converting-pairs}
Recall that a congruence $\rho$ on a semigroup $S$ can be stored using
a subset of the pairs in $\rho$.  If $\R$ is a subset of $S \times S$,
then we can say that $\R$ \textit{generates} a congruence.  The
congruence \textit{generated by} $\R$ is defined as the least congruence
on $S$ containing all the pairs in $\R$; equivalently, it is defined as
the intersection of all congruences on $S$ containing all the pairs in
$\R$.  It is denoted by $\R^\sharp$ (see Theorem
\ref{thm:rsharp}).  We have similarly defined the left congruence generated by
$\R$ (denoted by $\R^\triangleleft$) and the right congruence
generated by $\R$ (denoted by $\R^\triangleright$).
A full explanation of how generating pairs can be used to represent congruences
is given in Section \ref{sec:intro-gen-pairs}, and an approach for computing
properties of congruences using their generating pairs is given in Chapter
\ref{chap:pairs}.

Given a set of pairs $\R$, we may wish to produce the congruence
$\R^\sharp$ and represent it using one of the other methods described in
this chapter.  It is of course possible to calculate the set of all pairs in
$\R^\sharp$ and convert that to the other representation; however, in
order to find other representations with as little work as possible, it is
desirable to use the pairs in $\R$ directly, calculating as few extra
pairs as possible---see, for example, Sections \ref{sec:pairs-to-linked-triple}
and \ref{sec:pairs-to-kertr}.  Conversely, if we wish to convert another
representation for a congruence $\rho$ to a set of generating pairs, it is
desirable to find as small a set of pairs as possible---see, for example,
Sections \ref{sec:linked-triple-to-pairs} and \ref{sec:kertr-to-pairs}.  When
converting between generating pairs and other representations, these will be the
goals.

\subsection{Groups: normal subgroups}
\label{sec:normal-subgroups}

In group theory, it is unusual to encounter discussion of congruences.  This is
because a group's congruences are closely related to another structure---its
normal subgroups---and any questions we could ask about a group's congruences are
easily described using normal subgroups instead.  Recall that a subgroup $N$ of
a group $G$ is \textit{normal} if and only if $g^{-1}ng \in N$ for all $g \in G$
and $n \in N$; recall also that a \textit{coset} of $N$ is the set $Ng$ or $gN$
for some $g \in G$, and that $Ng=gN$ if $N$ is normal.  The following theorem
shows how a group's normal subgroups are in bijective correspondence with its
congruences.

\begin{theorem}
  \label{thm:normal-subgroups}
  Let $G$ be a group.  If $\rho$ is a congruence on $G$, then the $\rho$-class
  containing the identity is a normal subgroup of $G$.

  Conversely, if $N$ is a normal subgroup of $G$, then its cosets are the
  classes of a congruence on $G$.

  \begin{proof}
    First, let $\rho$ be a congruence on $G$, and let $I$ be the $\rho$-class
    containing the identity $1$.  First we show that $I$ is a subgroup: if
    $a,b \in I$ then $ab ~\rho~ 11 = 1$, so $ab \in I$.
    Furthermore, we have $(a,1) \in \rho$, so
    $(aa^{-1}, 1a^{-1}) = (1, a^{-1}) \in \rho$, so $a^{-1} \in I$, and so
    $I$ is a subgroup.  To show $I$ is normal, let $g \in G$ and $i \in I$.
    Observe that $g^{-1}ig ~\rho~ g^{-1}1g = g^{-1}g = 1$, so $g^{-1}ig \in I$,
    as required.

    To show the converse, let $N$ be a normal subgroup of $G$, and let $\nu$ be
    the equivalence on $G$ whose classes are the cosets of $N$.  If
    $(x,y), (s,t) \in \nu$, then $Nx=Ny$ and $sN=tN$.  Hence
    $Nxs=Nys=ysN=ytN=Nyt$, so we have $(xs,yt) \in \nu$, meaning that $\nu$ is
    a congruence as required.
  \end{proof}
\end{theorem}

This theorem means that any information which can be taken from a congruence can
instead be taken from a normal subgroup, and so congruences on a group need
never be studied directly.  We even have the fortunate property that the
containment of normal subgroups follows the containment of the corresponding
congruences.  The other structures discussed in this section represent
congruences on other categories of semigroup in a similar way.



\subsection{Completely (0-)simple semigroups: linked triples}
\label{sec:linked-triples}

There is a special way of describing a congruence on a completely simple or
completely 0-simple semigroup: using a linked triple.  We will start by
explaining the terms \textit{completely simple} and \textit{completely
  0-simple}, then we will define a semigroup's linked triples and explain how
they are related to its congruences.

\begin{definition}
  \label{def:zerosimple}
  A semigroup $S$ is:
  \begin{itemize}
  \item \textbf{simple} if its only ideal is $S$;
  \item \textbf{0-simple} if it has a zero, and its only ideals are $S$ and
    $\{0\}$.
  \end{itemize}
\end{definition}

Simple and 0-simple semigroups are closely related.  Note that if $S$ is a
simple semigroup, then $S^0$, the semigroup created by appending a zero element
to $S$, is 0-simple.
Next, we consider a slightly stronger condition, after a preliminary definition
relating to idempotents.

\begin{definition}
  \label{def:primitive}
  An idempotent $p \in S$ is \textbf{primitive} if it is non-zero and there is
  no other non-zero idempotent $i \in S$ such that $ip = pi = i$.
\end{definition}

\begin{definition}
  \label{def:completelyzerosimple}
  A semigroup is:
  \begin{itemize}
  \item \textbf{completely simple} if it is simple and contains a primitive
    idempotent;
  \item \textbf{completely 0-simple} if it is 0-simple and contains a primitive
    idempotent.
  \end{itemize}
  %TODO: rephrase in terms of partial ordering of idempotents?
\end{definition}

Definitions \ref{def:zerosimple} and \ref{def:completelyzerosimple} are
equivalent for finite semigroups---that is to say, a finite semigroup is
completely simple if and only if it is simple, and it is completely 0-simple if
and only if it is 0-simple.  Some of the conversions described in this chapter
will be applicable only to finite semigroups, and in those circumstances we will
refer to \textit{finite simple} or \textit{finite 0-simple} semigroups, knowing
that these are completely simple or completely 0-simple, respectively.
Note that a finite semigroup is simple if and only if it is $\JJ$-trivial.
%TODO: only finite?

Completely simple and completely 0-simple semigroups have a strong and useful
isomorphism property, which allows us to say a great deal about their structure
and, in particular, their congruences.  We will consider first the more
complicated case, that of completely 0-simple semigroups, and then at the end of
this section we will explain how this theory can be adapted for the much less
complicated case, that of completely simple semigroups.

\begin{definition}[\S 3.2 in \cite{howie}]
  \label{def:rzms}
  A \textbf{Rees 0-matrix semigroup} $\mathcal{M}^0[T;I,\Lambda;P]$ is the set
  $$(I \times T \times \Lambda) \cup \{0\}$$
  with multiplication given by
  $$(i,a,\lambda) \cdot (j,b,\mu) = \left\{
    \begin{array}{l l}
      (i,ap_{\lambda j}b, \mu) & \text{if~} p_{\lambda j} \neq 0, \\
      0 & \text{otherwise,}
    \end{array}
  \right.$$
  where
  \begin{itemize}
  \item $T$ is a semigroup,
  \item $I$ and $\Lambda$ are index sets,
  \item $P$ is a $|\Lambda| \times |I|$ matrix with entries $(p_{\lambda
      i})_{\lambda \in \Lambda, i \in I}$
    taken from $T^0$,
  \item $0x=x0=0$ for all $x \in \mathcal{M}^0[T;I,\Lambda;P]$.
  \end{itemize}
\end{definition}

We will require a certain property of the matrix $P$, which we should define
first: we call a matrix \textbf{regular} if it contains at least one
non-zero entry in each row and each column.

The following theorem shows how we can use Rees 0-matrix semigroups to classify
completely 0-simple semigroups.

\begin{theorem}[Rees]
  \label{thm:rees}
  Every completely 0-simple semigroup is isomorphic to a Rees 0-matrix semigroup
  $\mathcal{M}^0[G;I,\Lambda;P]$, where $G$ is a group and $P$ is regular.
  Conversely, every such Rees 0-matrix semigroup is completely 0-simple.
  \begin{proof}
    Theorem 3.2.3 in \cite{howie}.
  \end{proof}
\end{theorem}

Now we can replace any completely 0-simple semigroup with its isomorphic Rees
0-matrix semigroup when we wish to perform any isomorphism-invariant
calculations---hence we can restrict our further investigations just to this
type of semigroup.  From now on, when we see a Rees 0-matrix semigroup over $G$,
we will assume that $G$ is a group.  Hence ``a completely 0-simple Rees 0-matrix
semigroup $\mathcal{M}^0[G;I,\Lambda;P]$'' refers to a completely 0-simple Rees
0-matrix semigroup over a group $G$, with a regular matrix $P$.  Note that if
$\mathcal{M}^0[G;I,\Lambda;P]$ is finite, then $G$, $I$, $\Lambda$ and $P$ are
all finite.

Next we consider the congruences of a finite 0-simple semigroup.

\begin{definition}
  \label{def:linked-triple}
  Let $S$ be a completely 0-simple Rees 0-matrix semigroup
  $\mathcal{M}^0[G;I,\Lambda;P]$.  A \textbf{linked triple} on $S$ is a
  triple $$(N,\mathcal{S},\mathcal{T})$$ consisting of a normal subgroup
  $N \trianglelefteq G$, an equivalence relation $\mathcal{S}$ on $I$ and an
  equivalence relation $\mathcal{T}$ on $\Lambda$, such that the following are
  satisfied:
  \begin{enumerate}
  \item $\mathcal{S} \subseteq \varepsilon_I$, where $\varepsilon_I =
    \left\{(i,j) \in I \times I\, \middle|\, \forall \lambda \in \Lambda:
      p_{\lambda i}=0 \iff p_{\lambda j}=0 \right\}$,
  \item $\mathcal{T} \subseteq \varepsilon_\Lambda$, where $\varepsilon_\Lambda
    = \left\{(\lambda,\mu) \in \Lambda \times \Lambda\, \middle|\, \forall i \in
      I: p_{\lambda i}=0 \iff p_{\mu i}=0 \right\}$,
  \item For all $i,j \in I$ and $\lambda, \mu \in \Lambda$ such that
    $p_{\lambda i}, p_{\lambda j}, p_{\mu i}, p_{\mu j} \neq 0$ and either
    $(i,j) \in \mathcal{S}$ or $(\lambda,\mu) \in \mathcal{T}$, we have
    $q_{\lambda \mu i j} \in N$, where
    $$q_{\lambda \mu i j} = p_{\lambda i} p_{\mu i}^{-1} p_{\mu j} p_{\lambda
      j}^{-1}.$$
  \end{enumerate}
  \cite[\S 3.5]{howie}
\end{definition}

We can associate the linked triples of a finite 0-simple semigroup with its
non-universal congruences, as follows.

\begin{theorem}
  \label{thm:linked-triple}
  Let $S$ be a completely 0-simple Rees 0-matrix semigroup.  There exists a
  bijection $\Gamma$ between the non-universal congruences on $S$ and the linked
  triples on $S$.
  \begin{proof}
    Theorem 3.5.8 in \cite{howie}
  \end{proof}
\end{theorem}

This theorem shows us an alternative way to look at congruences on completely
0-simple semigroups, just as normal subgroups show us an alternative way to look
at congruences on groups.  However, in order to use this at all in a
computational setting, we must have a concrete function $\Gamma$ which we can
use to convert a congruence to a linked triple and back again, rather than just
the knowledge that such a function exists---indeed, describing such a function
is the purpose of this section.  We define the function $\Gamma$ as follows.

\begin{definition}[\S 3.5 in \cite{howie}]
  \label{def:linked-triple-function}
  Let $S$ be a completely 0-simple Rees 0-matrix semigroup
  $\mathcal{M}^0[G;I,\Lambda;P]$, and let $\rho$ be a non-universal congruence
  on $S$.
  The \textbf{linked triple function} of $S$ is the function
  $$\Gamma: \rho \mapsto (N_\rho, \mathcal{S}_\rho, \mathcal{T}_\rho),$$
  which maps any non-universal congruence onto a triple whose entries are
  defined as follows.

  The relation $\mathcal{S}_\rho \subseteq I \times I$ is defined by the rule that
  $(i,j) \in \mathcal{S}_\rho$ if and only if $(i,j) \in \varepsilon_I$ and
  $$(i, p_{\lambda i}^{-1}, \lambda) ~\rho~ (j, p_{\lambda j}^{-1}, \lambda)$$
  for all $\lambda \in \Lambda$ such that $p_{\lambda i} \neq 0$ (and hence
  $p_{\lambda j} \neq 0$).  Similarly, the relation
  $\mathcal{T}_\rho \subseteq \Lambda \times \Lambda$ is defined by the rule that
  $(\lambda,\mu) \in \mathcal{T}_\rho$ if and only if
  $(\lambda,\mu) \in \varepsilon_\Lambda$ and
  $$(i, p_{\lambda i}^{-1}, \lambda) ~\rho~ (i, p_{\mu i}^{-1}, \mu)$$
  for all $i \in I$ such that $p_{\lambda i} \neq 0$ (and hence
  $p_{\mu i} \neq 0$).  Finally, we define the normal subgroup
  $N_\rho \trianglelefteq G$ as follows.  First, fix some $\xi \in \Lambda$, a
  row of the matrix $P$.  Since $P$ is regular, row $\xi$ must contain a
  non-zero entry---fix some $k \in I$ such that $p_{\xi k} \neq 0$.  Now we can
  define
  $$N_\rho = \{a \in G ~|~ (k, a, \xi) ~\rho~ (k, 1_G, \xi)\},$$
  where $1_G$ is the identity in the group $G$.
  The inverse of $\Gamma$ is then such that
  $(N, \mathcal{S}, \mathcal{T})\Gamma^{-1}$ is equal to
  $$\Big\{
  \big((i, a, \lambda), (j, b, \mu)\big) ~\Big|~
  (p_{\xi i} a p_{\lambda x}) (p_{\xi j} b p_{\mu x})^{-1} \in N, 
  (i,j) \in \mathcal{S},
  (\lambda,\mu) \in \mathcal{T}
  \Big\},$$
  where $\xi \in \Lambda$ and $x \in I$ can be any elements such that
  $p_{\xi i}$ and $p_{\lambda x}$ are both non-zero.
\end{definition}

Note that the definition of $N_\rho$ does not depend on the choice of $\xi$ and
$k$.  Independence from the choice of $\xi$ is established by the following
lemma, and independence from the choice of $k$ follows by a similar argument.

\begin{lemma}
  Let $\xi_1, \xi_2 \in \Lambda$ and $k \in I$ such that $p_{\xi_1k}^{} \neq 0$
  and $p_{\xi_2 k}^{} \neq 0$.  Then
  $$(k, a, \xi_1) ~\rho~ (k, 1_G, \xi_1)
  \quad \text{if and only if} \quad
  (k, a, \xi_2) ~\rho~ (k, 1_G, \xi_2)$$
  for all $a \in G$.
  \begin{proof}
    Assume that $(k, a, \xi_1) ~\rho~ (k, 1_G, \xi_1)$.  We can right-multiply
    both sides by $(k, p_{\xi_1k}^{-1}, \xi_2)$ to give
    $$(k, a, \xi_1)(k, p_{\xi_1k}^{-1}, \xi_2)
    ~\rho~ (k, 1_G, \xi_1)(k, p_{\xi_1k}^{-1}, \xi_2),$$
    which simplifies to
    $$(k, a p_{\xi_1k}^{} p_{\xi_1k}^{-1}, \xi_2)
    ~\rho~ (k, 1_G p_{\xi_1k}^{} p_{\xi_1k}^{-1}, \xi_2),$$
    and then to
    $(k, a, \xi_2) ~\rho~ (k, 1_G, \xi_2)$,
    as required.
    The converse argument is identical, swapping $\xi_1$ for $\xi_2$.
  \end{proof}
\end{lemma}

Our discussion so far has focused on 0-simple semigroups, but very similar
structures exist for completely \textit{simple} semigroups.  They are isomorphic
to \textit{Rees matrix semigroups}, and linked triples can be defined on them in
almost exactly the same way, except for the removal of complications related to
the zero element.  A Rees matrix semigroup follows Definition \ref{def:rzms} but
with the removal of the zero element, and linked triples follow Definition
\ref{def:linked-triple}, where the restrictions related to placements of $0$ in
$P$ are irrelevant.  It should also be noted that even the universal congruence
has a linked triple in this
case---$(G, I \times I, \Lambda \times \Lambda)$---so the domain of $\Gamma$ is
not only the non-universal congruences, but all congruences on $S$.

\subsection{Inverse semigroups: kernel-trace pairs}
\label{sec:kertr}

An inverse semigroup also has a structure which can be used in place of its
congruences: its \textit{kernel-trace pairs} (sometimes confusingly known as
``congruence pairs'').  In \cite[Chapter 5]{mtorpey_msc} the author focused on a
computational use of kernel-trace pairs to solve problems about congruences.
They can certainly be used effectively to carry out calculations, in a similar
way to linked triples.

The basic theory about kernel-trace pairs is presented here, for reference.  In
all these definitions, $S$ is an inverse semigroup, $E$ is the set of
idempotents in $S$, and and $\rho$ is a congruence on $S$.  Recall that $E$ is
an inverse subsemigroup of $S$.  This is standard background theory, which is
adapted from \cite[\S 5.3]{howie}.

\begin{definition}
  \label{def:kernel}
  The \textbf{kernel} of $\rho$ is $\bigcup_{e \in E} [e]_\rho$, the union of
  all the $\rho$-classes of $S$ which contain idempotents.  It is denoted by
  $\ker\rho$.
\end{definition}

\begin{definition}
  \label{def:trace}
  The \textbf{trace} of $\rho$ is $\rho \cap (E \times E)$, the restriction of
  $\rho$ to the idempotents of $S$.  It is denoted by $\tr\rho$.
\end{definition}

We will shortly see that a congruence on $S$ is completely defined by its kernel
and trace.  First we will approach kernel-trace pairs from an abstract route
which will help us to classify the congruences on $S$ completely.  We start with
two different definitions of the word ``normal'', one for subsemigroups and one
for congruences.

\begin{definition}
  \label{def:kernel-normal}
  A subsemigroup $K$ of $S$ is called \textbf{normal} if it is
  \textit{full} (contains all the idempotents of $S$) and
  \textit{self-conjugate} ($a^{-1}xa \in K$ for all $x \in K, a \in S$).
\end{definition}

\begin{definition}
  \label{def:trace-normal}
  A congruence $\tau$ on $E$ is \textbf{normal} in $S$ if
  $$(a^{-1}ea,a^{-1}fa) \in \tau$$
  for every pair $(e,f) \in \tau$ and every element $a \in S$.
\end{definition}

Now we can define a \textit{kernel-trace pair}, an abstract structure which
relates very closely to a congruence.

\begin{definition}
  \label{def:kernel-trace-pair}
  A \textbf{kernel-trace pair} on $S$ is a pair $(K,\tau)$ consisting of a
  normal subsemigroup $K$ of $S$ and a normal congruence $\tau$ on $E$, such
  that
  \begin{enumerate}
  \item If $ae \in K$ and $(e,a^{-1}a) \in \tau$, then $a \in K$
  \item If $a \in K$, then $(aa^{-1},a^{-1}a) \in \tau$
  \end{enumerate}
  for all elements $a \in S$ and $e \in E$.
\end{definition}

Now we state the result which identifies an abstract kernel-trace pair with the
kernel and trace of a congruence, and allows us to calculate information about
$\rho$ by using $\ker \rho$ and $\tr \rho$ directly.

\begin{theorem}
  \label{thm:kernel-trace-pair}
  % Let $\rho$ be a congruence on an inverse semigroup $S$ with idempotent
  % semigroup $E$.  $(\ker\rho, \tr\rho)$ is a kernel-trace pair.

  % Conversely, every kernel-trace pair $(K,\tau)$ on $S$ defines a congruence
  % $$\rho_{(K,\tau)} = \{(x,y) \in S \times S ~|~ (x^{-1}x, y^{-1}y) \in \tau,
  % xy^{-1} \in K\}$$
  % whose kernel is equal to $K$ and whose trace is equal to $\tau$.  Finally,
  % $\rho_{(\ker\rho,\tr\rho)} = \rho$.
  Let $S$ be an inverse semigroup.  There exists a bijection $\Psi$ from the
  congruences on $S$ to the kernel-trace pairs on $S$, defined by
  $$\Psi: \rho \mapsto (\ker\rho, \tr\rho),$$
  and its inverse satisfies
  $$\Psi^{-1} : (K,\tau) \mapsto
  \{(x,y) \in S \times S ~|~ xy^{-1} \in K, (x^{-1}x, y^{-1}y) \in \tau\}.$$
  \begin{proof}
    Theorem 5.3.3 in \cite{howie}.
  \end{proof}
\end{theorem}

This theorem tells us everything we need to know about kernel-trace pairs and
their relationship to congruences on an inverse semigroup.  Once we have the
kernel-trace pair of a congruence, we can solve any problem we wish to using the
kernel and trace alone, and computational problems such as determining whether a
given pair $(x,y)$ lies in the congruence are much faster than using
generating pairs directly \cite[\S 6.1.3]{mtorpey_msc}.  However, we may find
that if a congruence is specified initially using generating pairs, it may be
costly to find its kernel-trace pair in the first place; Section
\ref{sec:pairs-to-kertr} presents a relatively fast method for finding a kernel-trace pair.

\subsection{Rees congruences}
\label{sec:converting-rees}
A \textbf{Rees congruence} is a congruence on a semigroup $S$ with a
distinguished congruence class $I$ which is a two-sided ideal of $S$, and in
which every other congruence class is a singleton.  We may write this congruence
as $\rho_I$, and we may write its quotient $S/\rho_I$ as $S/I$.  Hence, a pair
$(x,y)$ lies in $\rho_I$ if and only if $x=y$ or $x$ and $y$ both lie in $I$.

Some or all of a semigroup's congruences may be Rees: in particular, since $S$
is an ideal of $S$, the universal congruence $S \times S$ is a Rees congruence
which could be written as $\rho_S$.  If $S$ has a zero $0$, then $\{0\}$ is an
ideal and so the trivial congruence $\Delta_S$ is a Rees congruence which could
be written as $\rho_{\{0\}}$.

As an example, the monoid of all order-preserving transformations $\OO_n$ has
only Rees congruences, apart from the trivial congruence $\Delta_{\OO_n}$, which
is not Rees, since $\OO_n$ does not contain a zero \cite{lavers_1999}.
Some examples of semigroups whose congruences are all Rees can be found in
\cite[\S 5]{garcia_1991}.

\section{Converting between representations}
\label{sec:converting}

In Section \ref{sec:ways-of-representing} we presented five different ways of
representing a congruence.  In this section, we present a survey of the
different ways in which they can be converted to each other.  Table
\ref{tab:converting} summarises the methods which exist, and the sections in
which they are described.

\subsection{Normal subgroups and linked triples}
\label{sec:normal-subgroup-to-linked-triple}
In this section we will consider how to convert between a normal subgroup (which
represents a congruence on a group) and a linked triple (which represents a
congruence on a simple semigroup).  This conversion is rather trivial, but is
presented as a good example of how different congruence representations can be
closely related.

Any group is a completely simple semigroup.  In fact, since any group $G$ has
precisely one $\HH$-class, it is isomorphic to the Rees matrix semigroup
$\mathcal{M}[G; I, \Lambda; P]$ where $|I|=|\Lambda|={1}$ and $P$ is the
$1 \times 1$ matrix $(1_G)$.  Let $\phi: G \to \mathcal{M}[G; I, \Lambda; P]$ be
the isomorphism defined by $(g)\phi = (1, g, 1)$.

As described in Theorem \ref{thm:normal-subgroups}, a congruence $\rho$ on a
group $G$ is associated with a normal subgroup $N \trianglelefteq G$, according
to the rule that $x ~\rho~ y$ if and only if $xy^{-1} \in N$.  Similarly, as
described in Definition \ref{def:linked-triple-function}, a congruence $\rho'$
on $\mathcal{M}[G; I, \Lambda; P]$ is associated with a linked triple
$(N', \mathcal{S}, \mathcal{T})$, according to the rule that
$(i, a, \lambda) ~\rho~ (j, b, \mu)$ if and only if $i ~\mathcal{S}~ j$,
$\lambda ~\mathcal{T}~ \mu$, and
$(p_{1 i} a p_{\lambda 1}) (p_{1 j} b p_{\mu 1})^{-1} \in N'$.
Since $|I|=|\Lambda|={1}$ and $P=(1_G)$, this last condition simplifies to
$ab^{-1} \in N'$.

Let $\rho'$ be the congruence on $\mathcal{M}[G; I, \Lambda; P]$ such that
$(x)\phi ~\rho~ (y)\phi$ (i.e.~$(1,x,1) ~\rho'~ (1,y,1)$) if and only if
$x ~\rho~ y$.  The condition defining $\rho$, that $xy^{-1} \in N$, is
equivalent to the condition defined by the linked triple
$(N, \Delta_I, \Delta_\Lambda)$, since $I$ and $\Lambda$ are both trivial.
Hence any normal subgroup $N$ corresponds to the linked triple
$(N, \Delta_I, \Delta_\Lambda)$, making linked triples on groups very easy to
deal with.

\subsection{Generating pairs of a Rees congruence}
\label{sec:rees-to-pairs}
A natural question, given an ideal $I$, is how to find a set of generating pairs
for the Rees congruence $\rho_I$.  In this section we will limit our discussion
to finite semigroups.

\begin{theorem}
  Let $S$ be a finite semigroup, and let $I$ be an ideal of $S$.  If $X$ is an ideal
  generating set for $I$ (see Definition \ref{def:ideal-generating-set}) and $M$
  is the minimal ideal of $S$ (which may or may not be equal to $I$), then
  $$X \times M$$ is a set of generating pairs for the Rees congruence $\rho_I$.
  \begin{proof}
    Let $\rho$ be the congruence generated by $X \times M$.  First we show that
    $\rho \subseteq \rho_I$, and then that $\rho_I \subseteq \rho$.

    Let $(i,m) \in X \times M$.  We have $X \subseteq I$ since $X$ is a
    generating set for $I$, and $M \subseteq I$ since $M$ is contained in any
    ideal of $S$.  Hence $i$ and $m$ both lie in $I$, so they are in the same
    class of the Rees congruence: $(i,m) \in \rho_I$.  Hence $X \times M
    \subseteq \rho_I$, and so $\rho$ (the least congruence containing $X \times
    M$) must also be contained in $\rho_I$.  Hence $\rho \subseteq \rho_I$.

    Now let $(a,b) \in \rho_I$; we wish to show that $(a,b) \in \rho$.  If $a=b$
    then we certainly have $(a,b) \in \rho$.  Otherwise we must have $a,b \in
    I$.  Since $X$ \textit{generates} $I$, we have $I = S^1XS^1$.  Therefore we
    can write
    $$a = s_1x_1t_1, \quad b = s_2x_2t_2,$$
    for some $x_1,x_2 \in X$ and $s_1,s_2,t_1,t_2 \in S^1$.

    Now choose some $m \in M$.  By definition $(x_1,m), (x_2,m) \in \rho$ since
    $X \times M \subseteq \rho$, and
    by the compatibility properties of a congruence,
    $$(s_1x_1t_1,s_1mt_1), (s_2x_2t_2,s_2mt_2) \in \rho.$$

    Since $m \in M$, we must have $s_1mt_1,s_2mt_2 \in M$.  Let $x_0$ be an
    arbitrary element of $X$.
    We see $(x_0,s_1mt_1), (x_0,s_2mt_2) \in X \times M$, and so by transitivity
    $(s_1mt_1, s_2mt_2) \in \rho$.
    Hence
    $$a ~=~ s_1x_1t_1 ~\rho~ s_1mt_1 ~\rho~ s_2mt_2 ~\rho~ s_2x_2t_2 = b,$$
    and $(a,b) \in \rho$ as required.
  \end{proof}
\end{theorem}

\subsection{Linked triple from generating pairs}
\label{sec:pairs-to-linked-triple}

In \cite[\S 6.1]{mtorpey_pre_msc} it is observed that calculating information
about a congruence using its linked triple is much faster than using a set of
generating pairs.  However, it may well be that a congruence on a finite
simple or finite 0-simple semigroup is specified by generating pairs, and we do
not know its linked triple \textit{a priori}.  In this case, we will need to
calculate the congruence's linked triple before we can use it to calculate any
other information.  We could do this by enumerating all the elements of all the
classes of the congruence, and then simply looking up the relevant information
to find the linked triple.  However, this is very expensive, and once the
classes are enumerated there is likely no need for the linked triple, since all
information about the congruence has been calculated.

In \cite[\S 3.2]{mtorpey_msc}, the author presents an algorithm to calculate a
congruence's linked triple directly from a set of generating pairs, calculating
as few extra pairs as possible.  This algorithm performs quickly, representing a
big improvement on using a more naive algorithm to find the linked triple
\cite[\S 6.1.2]{mtorpey_msc}.  The algorithm is justified by the following
definition and theorem from \cite{mtorpey_msc}.

\begin{definition}[Definition 3.10 in \cite{mtorpey_msc}]
  \label{def:ri}
  For a finite 0-simple Rees 0-matrix semigroup
  $\mathcal{M}^0[G;I,\Lambda;P]$, we define the relations
  $\mathbf{R}_I$ and $\mathbf{R}_\Lambda$ by
  $$\mathbf{R}_I = \big\{(i,j) \in I \times I ~\big|~
  (i,a,\lambda) ~\mathbf{R}~ (j,b,\mu) ~\text{for some}~
  a,b \in G,~\lambda,\mu \in \Lambda\big\},$$
  $$\mathbf{R}_\Lambda = \big\{(\lambda,\mu) \in \Lambda \times \Lambda ~\big|~
  (i,a,\lambda) ~\mathbf{R}~ (j,b,\mu) ~\text{for some}~
  a,b \in G,~i,j \in I\big\}.$$
\end{definition}

\begin{theorem}[Theorem 3.11 in \cite{mtorpey_msc}]
  \label{thm:pairs-to-linked-triple}
  Let $S = \mathcal{M}^0[G;I,\Lambda;P]$ be a finite 0-simple semigroup, with a
  relation $\R \subset S \times S$ that generates a non-universal
  congruence $\R^\sharp$.  Let
  $\mathcal{S}_{\Rs} = (\R|_I)^e$, let
  $\mathcal{T}_{\Rs} = (\R|_\Lambda)^e$, and let $N_{\Rs}$ be
  the least normal subgroup of $G$ containing the set
  \begin{align*}
    \Big\{(p_{\xi i} a p_{\lambda x}) (p_{\xi j} b p_{\mu x})^{-1} ~\Big|~
    & i,j,x \in I,\ \lambda, \mu, \xi \in \Lambda,\ a,b \in G \\
    & \text{such that~} (i,a,\lambda) ~\R~ (j,b,\mu) \text{~and~}
      p_{\xi i}, p_{\lambda x} \neq 0\Big\} \\
    \cup~ \Big\{q_{\lambda \mu i j} ~\Big|~ &
           (i,j) \in \R|_I,~
           \lambda,\mu \in \Lambda ~\textnormal{such that}~
           p_{\lambda i}, p_{\mu i} \neq 0\Big\} \\
    \cup~ \Big\{q_{\lambda \mu i j} ~\Big|~ &
           (\lambda,\mu) \in \R|_\Lambda,~
           i,j \in I ~\textnormal{such that}~
           p_{\lambda i}, p_{\lambda j} \neq 0\Big\}. \\
  \end{align*}
  Then $(N_{\Rs}, \mathcal{S}_{\Rs}, \mathcal{T}_{\Rs})$
  is the linked triple corresponding to $\R^\sharp$.
\end{theorem}

This theorem is enough to justify the algorithm for converting a set of
generating pairs to a linked triple.  We present the algorithm here as Algorithm
\ref{alg:pairs-to-linked-triple}.  In reading the algorithm, it will be helpful
to refer to Definition \ref{def:linked-triple} for the relations $\varepsilon_I$
and $\varepsilon_\Lambda$ and elements of the form $q_{\lambda \mu i j}$.
For a fuller description of the algorithm and how it is justified by Theorem
\ref{thm:pairs-to-linked-triple}, see \cite[\S 3.2]{mtorpey_msc}.

\begin{algorithm}
\caption{The linked triple of a congruence by generating pairs}
\label{alg:pairs-to-linked-triple}
\begin{algorithmic}[1]
    \Require $\mathcal{M}^0[G;I,\Lambda;P]$ is a finite 0-simple Rees 0-matrix semigroup
    \Procedure{LinkedTripleFromPairs}{$\R$}
      \State $\mathcal{S} := \Delta_I$
      \State $\mathcal{T} := \Delta_\Lambda$
      \State $X := \varnothing$
      \For{$(x,y) \in \R$}
        \LComment{Check for the universal congruence}
        \If{$x=y$}
          \State \Continue
        \ElsIf{$x=0 \Or y=0$}
          \State \Return Universal Congruence (no linked triple)
        \EndIf
        \State Let $x=(i,a,\lambda)$
        \State Let $y=(j,b,\mu)$
        \If{$(i,j) \notin \varepsilon_I \Or
          (\lambda,\mu) \notin \varepsilon_\Lambda$}
          \State \Return Universal Congruence (no linked triple)
        \EndIf

%        \State
        \LComment{Combine row and column classes}
        \State Combine $[i]_\mathcal{S}$ with $[j]_\mathcal{S}$
        \State Combine $[\lambda]_\mathcal{T}$ with $[\mu]_\mathcal{T}$

%        \State
        \LComment{Add generators for normal subgroup}
        \State Choose $\nu \in \Lambda$ such that $p_{\nu i} \neq 0$
        \State Choose $k \in I$ such that $p_{\lambda k} \neq 0$
        \State $X \gets X \cup \{(p_{\nu i}ap_{\lambda k})(p_{\nu j}bp_{\mu k})^{-1}\}$

%        \State
        \For{$\xi \in \Lambda \setminus \{\nu\}$ such that $p_{\xi i} \neq 0$}
          \State $X \gets X \cup \{q_{\nu \xi i j}\}$
        \EndFor
        \For{$x \in I \setminus \{k\}$ such that $p_{\lambda x} \neq 0$}
          \State $X \gets X \cup \{q_{\lambda \mu k x}\}$
        \EndFor
      \EndFor
      \State $N := \llangle X \rrangle$
      \State \Return $(N,\mathcal{S},\mathcal{T})$
    \EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Generating pairs from a linked triple}
\label{sec:linked-triple-to-pairs}

Let $S$ be a completely simple or completely 0-simple semigroup, and let $\rho$
be a congruence on $S$.  In Section \ref{sec:pairs-to-linked-triple} we
presented an algorithm to find the linked triple of $\rho$, given only a set of
generating pairs for $\rho$.  In this section, we will present the reverse: an
method to find a set of generating pairs for $\rho$ given only its linked triple
$(N, \mathcal{S}, \mathcal{T})$.

Firstly we require a lemma describing the inclusion of congruences in each
other, and how it mirrors an inclusion of linked triples.

\begin{lemma}[Lemma 3.9 in \cite{mtorpey_msc}]
  \label{lem:linked-triple-subsets}
  Let $\rho$ and $\sigma$ be congruences on $S$ with linked triples
  $(N_\rho, \mathcal{S}_\rho, \mathcal{T}_\rho)$ and
  $(N_\sigma, \mathcal{S}_\sigma, \mathcal{T}_\sigma)$ respectively.
  We have $\rho \subseteq \sigma$ if and only if
  $N_\rho \leq N_\sigma$,
  $\mathcal{S}_\rho \subseteq \mathcal{S}_\sigma$, and
  $\mathcal{T}_\rho \subseteq \mathcal{T}_\sigma$.
\end{lemma}

Now we can state the main theorem which will inform this algorithm.  It also
relies on ideas from Theorem \ref{thm:pairs-to-linked-triple}.

\begin{theorem}
  \label{thm:linked-triple-to-pairs}
  Let $S = \mathcal{M}^0[G;I,\Lambda;P]$ be a finite 0-simple semigroup, and let
  $\rho$ be a congruence with linked triple
  $(N_\rho, \sS_\rho, \tT_\rho)$.
  Let $X_N \subseteq N$, $X_{\sS} \subseteq \sS$ and $X_\tT \subseteq \tT$ be
  subsets with the following properties:
  \begin{itemize}
  \item $N_\rho$ is the normal closure of $X_N$ in $G$,
  \item $\sS_\rho = (X_\sS)^e$,
  \item $\tT_\rho = (X_\tT)^e$.
  \end{itemize}
  If $\R$ is a subset of $\rho$ such that
  \begin{enumerate}
  \item for each pair $(i, j) \in X_\sS$ there exist $\lambda, \mu \in \Lambda$
    and $a, b \in G$ such that $(i, a, \lambda) ~\R~ (j, b, \mu)$;
  \item for each pair $(\lambda, \mu) \in X_\tT$ there exist $i, j \in I$ and
    $a, b \in G$ such that $(i, a, \lambda) ~\R~ (j, b, \mu)$;
  \item for each element $n \in X_N$ there exist $i,j,x \in I$ and $\lambda,
    \mu, \xi \in \Lambda$ such that $p_{\xi i}$ and $p_{\lambda x}$ are both
    non-zero and
    $$(i, p_{\xi i}^{-1} n p_{\lambda x}^{-1}, \lambda) ~\R~
    (j, p_{\xi j}^{-1} p_{\mu x}^{-1}, \mu);$$
  \end{enumerate}
  then $\R^\sharp = \rho$.

  \begin{proof}
    Assume $\R$ is as stated.  Since $\rho$ is a congruence and
    $\R \subseteq \rho$, we know that $\R^\sharp \subseteq \rho$.  Hence we only
    need to show that $\rho \subseteq \R^\sharp$.

    Let $(N_{\Rs}, \sS_{\Rs}, \tT_{\Rs})$ denote the linked triple associated with
    $\R^\sharp$.  We will show that $N_\rho \subseteq N_{\Rs}$,
    $\sS_\rho \subseteq \sS_{\Rs}$, and $\tT_\rho \subseteq \tT_{\Rs}$, and therefore
    that $\rho \subseteq \R$ by Lemma \ref{lem:linked-triple-subsets}.

    Recall the relations $\R_I$ and $\R_\Lambda$ from Definition \ref{def:ri}.
    By condition 1 above we can see that $X_\sS \subseteq \R_I$ and hence
    $(X_\sS)^e \subseteq (\R_I)^e$.  Meanwhile by Theorem
    \ref{thm:pairs-to-linked-triple} we have $(\R_I)^e = \mathcal{S}_{\Rs}$.  In
    total this gives us
    $\sS_\rho = (X_\sS)^e \subseteq (\R_I)^e = \mathcal{S}_{\Rs}$, so
    $\sS_\rho \subseteq \sS_{\Rs}$.  Similarly by condition 2 we have
    $\tT_\rho \subseteq \tT_{\Rs}$.

    Now we turn our attention to $N_\rho$, and its generating set $X_N$---we
    wish to show that $N_\rho \subseteq N_{\Rs}$.  Let $n \in X_N$.  By condition
    3, there exist $i, j, x \in I$ and $\lambda, \mu, \xi \in \Lambda$ such that
    $p_{\xi i}$ and $p_{\lambda x}$ are both non-zero and
    $(i, a, \lambda) ~\R~ (j, b, \mu)$, where
    $$a = p_{\xi i}^{-1} n p_{\lambda x}^{-1} \qquad \text{and} \qquad
    b = p_{\xi j}^{-1} p_{\mu x}^{-1}.$$
    Note that $p_{\xi j}$ and $p_{\mu x}$
    must also be non-zero since $(i, j) \in \varepsilon_I$ and
    $(\lambda, \mu) \in \varepsilon_\Lambda$.  To see that $n \in N_{\Rs}$, observe
    that $p_{\xi i} a p_{\lambda x} = n$ and $p_{\xi j} b p_{\mu x} = 1_G$.
    Hence $n$ satisfies the condition that
    $$n = (p_{\xi i} a p_{\lambda x}) (p_{\xi j} b p_{\mu x})^{-1}$$
    for some $i,j,x \in I$, some $\lambda, \mu, \xi \in \Lambda$, and some
    $a,b \in G$ such that $(i,a,\lambda) ~\R~ (j,b,\mu)$ and $p_{\xi i}$
    and $p_{\lambda x}$ are non-zero; this is precisely the requirement in
    Theorem \ref{thm:pairs-to-linked-triple} which means that $n \in N_{\Rs}$.
    Hence $X_N \subseteq N_{\Rs}$.  And since $N_\rho$ is the normal closure of
    $X_N$, and $N_{\Rs}$ is a normal subgroup, we have $N_\rho \subseteq N_{\Rs}$.

    Since $N_\rho \subseteq N_{\Rs}$, $\sS_\rho \subseteq \sS_{\Rs}$ and
    $\tT_\rho \subseteq \tT_{\Rs}$, Lemma \ref{lem:linked-triple-subsets} gives us
    $\rho \subseteq \R^\sharp$, as required.
  \end{proof}
\end{theorem}

Theorem \ref{thm:linked-triple-to-pairs} is enough to justify the
\textsc{GeneratingPairsFromLinkedTriple} algorithm, which is presented in this
thesis as Algorithm \ref{alg:linked-triple-to-pairs}.  Given a linked triple, we
only need to choose applicable subsets $X_N$, $X_\sS$ and $X_\tT$ and we have a
good idea of what pairs are necessary to generate a congruence.  In the
algorithm, we assume that a generating set $X_N$ is known for $N$---this is
certainly likely to be the case in a computational setting, for example in GAP
\cite{gap} where groups almost always have a known generating set.  We should
note that this set should act as a set of normal subgroup generators, meaning
that it might be even smaller than a standard set of group generators.  For
$X_\sS$ we choose a minimal spanning tree for each class of $\sS$, by linking
each column in the class to a distinguished class representative called $i_1$.
Hence each class requires a number of pairs in $X_S$ equal to one less than the
size of the class; and so $|X_\sS| = |I| - k_\sS$, where $k_\sS$ is the number
of classes in $\sS$.  Similarly $|X_\tT| = |\Lambda| - k_\tT$, where $k_\tT$ is
the number of classes in $\tT$.

Once our three generating sets have been calculated, we collate them into the
set of pairs $\R$ as efficiently as possible: each pair we add to $\R$ can
satisfy the conditions in Theorem \ref{thm:linked-triple-to-pairs} for one pair
$(i,j) \in X_\sS$, one pair $(\lambda, \mu) \in X_\tT$, and one element
$n \in X_N$: the pair we add is
$$\big((i, p_{\xi i}^{-1}ap_{\lambda k}^{-1}, \lambda),
(j, p_{\xi j}^{-1}ap_{\mu k}^{-1}, \mu)\big),$$
which can be seen by inspection to satisfy conditions 1, 2 and 3 for the three
generators in question.  These pairs are added until all three $X$ sets are
exhausted, and so the total number of pairs returned by the algorithm is equal
to
$$\max(|X_N|, |I| - k_\sS, |\Lambda| - k_\tT).$$
If the $X$ sets have different sizes, then any element can be reused from one of
the sets when it runs out---in Algorithm \ref{alg:linked-triple-to-pairs} the
last one popped is used repeatedly.  If any of the $X$ sets are empty at the
start, an arbitrary entry can be used instead: for $n$ we can use the identity
$1_G$ which must always be in $N$; for $(i,j)$ or $(\lambda,\mu)$ we can use a
reflexive pair, from $\Delta_I$ or $\Delta_\Lambda$ respectively.

\begin{algorithm}
\caption{Generating pairs of a linked triple}
\label{alg:linked-triple-to-pairs}
\begin{algorithmic}[1]
  \Procedure{GeneratingPairsFromLinkedTriple}{$(N, \mathcal{S}, \mathcal{T})$}
    \State $X_N := $ generating set for $N$
    \State $X_\mathcal{S} := \varnothing$
    \For{each non-singleton class $\{i_1, i_2, \ldots, i_n\}$ of $\mathcal{S}$}
      \For{$l \in \{2, \ldots, n\}$}
        \State \textsc{Push} $(i_1, i_l)$ onto $X_\mathcal{S}$
      \EndFor
    \EndFor
    \State $X_\mathcal{T} := \varnothing$
    \For{each non-singleton class $\{\lambda_1, \lambda_2, \ldots, \lambda_n\}$ of $\mathcal{T}$}
      \For{$l \in \{2, \ldots, n\}$}
        \State \textsc{Push} $(\lambda_1, \lambda_l)$ onto $X_\mathcal{T}$
      \EndFor
    \EndFor
    \State $\R := \varnothing$
    %\State $m := \max (|X_N|, |X_\mathcal{S}|, |X_\mathcal{T}|)$
    \State $a := 1_G$
    \State $(i,j) := (1,1)$
    \State $(\lambda,\mu) := (1,1)$
    \While{$X_N \neq \varnothing$ \Or $X_\mathcal{S} \neq \varnothing$ \Or $X_\mathcal{T} \neq \varnothing$}
      \If{$X_N \neq \varnothing$}
        \State $a \gets$ \Call{Pop}{$X_N$}
      \EndIf
      \If{$X_\mathcal{S} \neq \varnothing$}
        \State $(i,j) \gets$ \Call{Pop}{$X_\mathcal{S}$}
      \EndIf
      \If{$X_\mathcal{T} \neq \varnothing$}
        \State $(\lambda, \mu) \gets$ \Call{Pop}{$X_\mathcal{T}$}
      \EndIf
      \State Fix some $\xi \in \Lambda$ such that $p_{\xi i} \neq 0$
      \State Fix some $k \in I$ such that $p_{\lambda k} \neq 0$
      \State $\R \gets \R \cup \left\{\big(
        (i, p_{\xi i}^{-1}ap_{\lambda k}^{-1}, \lambda),
        (j, p_{\xi j}^{-1}ap_{\mu k}^{-1}, \mu)
        \big)\right\}$
    \EndWhile
    \State \Return $\R$
  \EndProcedure
\end{algorithmic}
\end{algorithm}


\subsection{Kernel and trace from generating pairs}
\label{sec:pairs-to-kertr}

Given a set of generating pairs $\R$ over a semigroup $S$, we may wish
to consider the congruence $\rho = \R^\sharp$ and ask questions such as
whether a pair lies in the congruence, or the number of congruence classes.
This is certainly possible by various methods, for example the variety of
algorithms mentioned in Chapter \ref{chap:pairs}---however, if $S$ is an inverse
semigroup then any calculation we wish to carry out will be much faster if we
know the congruence's kernel-trace pair, as described in Section
\ref{sec:kertr}.  We therefore wish for an algorithm that determines the kernel
and trace of $\rho$.

One way of calculating the kernel and trace would be simply to enumerate all the
elements in all the classes of $\rho$, and to search for the idempotents to
compute the kernel and trace.  However, enumerating all the classes is very
time-consuming, and the main reason to calculate the kernel-trace pair in the
first place is probably to avoid this work.  Hence, we want to find the
kernel-trace pair directly from the generating pairs $\R$, enumerating
as few pairs in $\R^\sharp$ as possible.

A new way of finding the kernel and trace directly from the generating pairs is
presented in pseudo-code in Algorithm \ref{alg:pairs-to-kertr}, which will
require some explanation.  It is based on a simple idea: firstly, populate $K$
and $\tau$ with those elements that are implied directly by the pairs in
$\R$; then, add further elements to $K$ and $\tau$ to satisfy the
conditions of a kernel-trace pair.  This means we return the least kernel-trace
pair $(K, \tau)$ that implies the pairs in $\R$---that is, we return
the kernel-trace pair that corresponds to $\R^\sharp$.  This idea is
explained more explicitly below.

\begin{algorithm}
\caption{The kernel-trace pair of a congruence by generating pairs}
\label{alg:pairs-to-kertr}
\begin{algorithmic}[1]
\Require $S$ an inverse semigroup with idempotents $E$
\Require $\R \subseteq S \times S$
\Procedure{KerTraceFromGenPairs}{$\R$}
\State $K := E$
\State $\tau := \Delta_E$
\State Let $S'$ be a generating set for $S$
\State Let $E'$ be a generating set for $E$
\State $X \gets E' \cup \{ab^{-1} : (a,b) \in \R\}$
\State $\mathbf{T} \gets \{(a^{-1}a, b^{-1}b) : (a,b) \in \R\}$
\State $\tau \gets (\tau \cup \mathbf{T})^e$
\Repeat
\State $\delta \gets \False$ \Comment{Nothing has changed yet}
\State \Call{EnumerateKernel}{ }
\State \Call{EnforceConditions}{ }
\State \Call{EnumerateTrace}{ }
\Until{$\delta = \False$} \Comment{Exit loop if nothing changed}
\State \Return $(K, \tau)$
\EndProcedure

\Procedure{EnumerateKernel}{ }
\If{$X \setminus K \neq \varnothing$}
  \State $K \gets \llangle K, X \rrangle$
  \State $\delta \gets \True$
\EndIf
\State $X \gets \varnothing$
\EndProcedure

\Procedure{EnforceConditions}{ }
\For{$a \in S$}
  \If{$a \in K$}
    \If{$(aa^{-1}, a^{-1}a) \notin \tau$}
      \State $\mathbf{T} \gets \mathbf{T} \cup \{(aa^{-1}, a^{-1}a)\}$
      \State $\tau \gets \tau \cup \{(aa^{-1}, a^{-1}a)\}$
      \State $\delta \gets \True$
    \EndIf
  \Else
    \For{$e \in [a^{-1}a]_\tau$}
      \If{$ae \in K$}
        \State $X \gets X \cup \{a\}$
        \State $\delta \gets \True$
      \EndIf
    \EndFor
  \EndIf
\EndFor
\EndProcedure

\Procedure{EnumerateTrace}{ }
\While{$\mathbf{T} \neq \varnothing$}
  \State Pick any $(x,y) \in \mathbf{T}$
  \For{$e \in E'$}
    \If{$(xe, ye) \notin \tau$}
      \State $\delta \gets \True$
      \State $\mathbf{T} \gets \mathbf{T} \cup \{(xe, ye)\}$
      \State $\tau \gets (\tau \cup \{(xe, ye)\})^e$
      \For{$a \in S'$}
        % TODO: should this be a^-1 xe a?
        \If{$(a^{-1}xa, a^{-1}ya) \notin \tau$}
          \State $\mathbf{T} \gets \mathbf{T} \cup \{(a^{-1}xa, a^{-1}ya)\}$
          \State $\tau \gets (\tau \cup \{(a^{-1}xa, a^{-1}ya)\})^e$
        \EndIf
      \EndFor
    \EndIf
  \EndFor
  \State $\mathbf{T} \gets \mathbf{T} \setminus \{(x,y)\}$
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

% kernelgenstoapply = $X$
% pairstoapply = $\mathbf{T}$
% traceBlocks/traceUF = $\tau$

To understand why the algorithm is correct, we make use of the following lemma,
akin to Lemma \ref{lem:linked-triple-subsets} for linked triples.

\begin{lemma}
  \label{lem:kertr-subsets}
  Let $\rho$ and $\sigma$ be congruences on $S$ with kernel-trace pairs
  $(K_\rho, \tau_\rho)$ and $(K_\sigma, \tau_\sigma)$ respectively.  We have
  $\rho \subseteq \sigma$ if and only if $K_\rho \leq K_\sigma$ and
  $\tau_\rho \subseteq \tau_\sigma$.
  \begin{proof}
    Assume $K_\rho \leq K_\sigma$ and $\tau_\rho \subseteq \tau_\sigma$, and let
    $(x,y) \in \rho$.  By Theorem \ref{thm:kernel-trace-pair}, we have
    $xy^{-1} \in K_\rho$ and $(x^{-1}x, y^{-1}y) \in \tau_\rho$.  Hence
    $xy^{-1} \in K_\sigma$ and $(x^{-1}x, y^{-1}y) \in \tau_\sigma$, which
    together imply $(x,y) \in \sigma$.  Hence $\rho \subseteq \sigma$.

    Conversely, assume $\rho \subseteq \sigma$.  If $k \in K_\rho$ then
    $k=xy^{-1}$ for some $(x,y) \in \rho$; this means $(x,y) \in \sigma$, so
    $k=xy^{-1} \in K_\sigma$.  Similarly, if $(e,f) \in \tau_\rho$ then
    $(e,f) = (x^{-1}x, y^{-1}y)$ for some $(x,y) \in \rho$; this means
    $(x,y) \in \sigma$, so $(e,f) = (x^{-1}x, y^{-1}y) \in \tau_\sigma$.  Hence
    $K_\rho \leq K_\sigma$ and $\tau_\rho \subseteq \tau_\sigma$, as
    required.
  \end{proof}
\end{lemma}

The kernel $K$ starts out containing just the idempotents $E$, and the trace
$\tau$ starts out as the trivial congruence on $E$.  Every kernel and trace must
contain at least these elements---in fact, $(K, \tau)$ currently corresponds to
the trivial congruence $\Delta_S$.  We assume that we have generating sets $S'$
for $S$ and $E'$ for $E$.  In the worst case, we can use $S$ and $E$ themselves,
but the algorithm is likely to run faster with a smaller generating set.
Certainly in computational settings such as the Semigroups package for GAP
\cite{semigroups} semigroups such as $S$ and $E$ have a generating set stored,
and a smaller generating set can sometimes be created by eliminating unnecessary
elements.

Once these setup steps have been done, we add information from the known pairs
of $\rho$---that is, from the pairs in $\R$.  Theorem
\ref{thm:kernel-trace-pair} tells us that a pair $(a,b)$ lies in $\rho$ if and
only if $ab^{-1} \in K$ and $(a^{-1}a, b^{-1}b) \in \tau$.  Now instead of using
$K$ and $\tau$ to determine whether a pair is in $\rho$, we are using a pair in
$\rho$ to impose conditions on $K$ and $\tau$.  We have two sets, $X$ and
$\mathbf{T}$, which act as queues for elements that need to be processed in $K$
and $\tau$ respectively.  For each $(a,b) \in \R$ we put $ab^{-1}$ into
$X$ and $(a^{-1}a, b^{-1}b)$ into $\mathbf{T}$; elements in $X$ will be added
to $K$ next time we call \textsc{EnumerateKernel}, and we add $\mathbf{T}$ to
$\tau$ straight away.

Once this has been done, the rule that $(a,b)$ lies in $\rho$ if and only if
$ab^{-1} \in K$ and $(a^{-1}a, b^{-1}b) \in \tau$ is satisfied for all pairs
$(a,b) \in \R$.  All that is left to do is to add any elements to $K$
and pairs to $\tau$ required to make $(K, \tau)$ a kernel-trace pair.  The rest
of the algorithm focuses on this task.

Recall from Definitions \ref{def:kernel-normal}, \ref{def:trace-normal} and
\ref{def:kernel-trace-pair} the conditions for a kernel-trace pair.  We require
$(K, \tau)$ to satisfy these conditions, and we must make any additions
necessary until they are all fulfilled.  For this purpose we have three
sub-methods---\textsc{EnumerateKernel}, \textsc{EnumerateTrace}, and
\textsc{EnforceConditions}---which test the conditions for a kernel-trace pair
and add any elements necessary.  Any of these methods might add to $K$ or
$\tau$, which might in turn imply that another method has more information to
find.  Hence, the three methods are run repeatedly until an entire run is
completed in which no new information is found.  If no new information is found,
$(K, \tau)$ is guaranteed to be a kernel-trace pair, and we can return.  The
three methods could be run in any order without the correctness of the algorithm
being affected, but the order shown in Algorithm \ref{alg:pairs-to-kertr} seems
to have the best time performance, based on informal experiments.  All three
methods are considered to have access to any of the variables in the overall
algorithm.

The first method, \textsc{EnumerateKernel}, adds all the elements from $X$ to
$K$, and takes the normal closure of $K$, ensuring that it is self-conjugate
(see Definition \ref{def:kernel-normal}).  Since $K$ starts containing $E$, this
is enough to guarantee that $K$ is a normal subsemigroup.

The \textsc{EnumerateTrace} method ensures that $\tau$ is a normal congruence
(see Definition \ref{def:trace-normal}).  It considers all the pairs that have
been added to $\tau$ since the last call to \textsc{EnumerateTrace}---these are
precisely the pairs in $\mathbf{T}$---and makes sure that any pairs implied by
them are added to $\tau$ and $\mathbf{T}$.  For each $(x,y) \in \mathbf{T}$, the
left and right multiples of $(x,y)$ must be in $\tau$ (as required by the
definition of a congruence).  In fact, only the right-multiples $(xe, ye)$ need
to be added, since idempotents commute in an inverse semigroup.  If any of these
pairs are new, they are added to $\mathbf{T}$ so that further multiples can be
found; this is why we only need to multiply by the generators from $E'$, rather
than all elements in $E$.  The congruence $\tau$ is also made normal by adding
the pairs $(a^{-1}xa, a^{-1}ya)$.  Thus, at the end of the method, $\tau$ is
guaranteed to be a normal congruence.

The last method, \textsc{EnforceConditions}, deals with conditions 1 and 2 from
Definition \ref{def:kernel-trace-pair}.  It adds any necessary elements to $X$
and any necessary pairs to $\mathbf{T}$ and $\tau$, and when finished,
$(K,\tau)$ is guaranteed to satisfy conditions 1 and 2, at least on a run in
which the other two methods make no changes.

If all three methods complete without any new information being found, they will
have acted as a test ensuring that $(K, \tau)$ is a valid kernel-trace pair.
This means that $(K, \tau)$ corresponds to a congruence $(K,\tau)\Psi^{-1}$, and
we know that this congruence contains every pair in $\R$.  Hence
$\R^\sharp \subseteq (K,\tau)\Psi^{-1}$.  Since we did not add any
elements to $K$ or $\tau$ except those implied by $\R$ or those required
by the definition of a kernel-trace pair, we can also be sure that
$(K, \tau)\Psi^{-1} \subseteq \R^\sharp$, by Lemma
\ref{lem:kertr-subsets}.  Hence $(K, \tau)$ is the kernel-trace pair
corresponding to the congruence $\R^\sharp$.

\subsection{Trivial conversions}
\label{sec:trivial-conversions}
Some of the conversions between different representations are particularly
trivial in nature, requiring almost no computational resources to calculate.
However, it is worth mentioning them here for completeness.

All groups are inverse semigroups.  Hence, if we have a congruence on a group,
it can be represented by a normal subgroup or by a kernel-trace pair.  Let
$\rho$ be such a congruence, on a group $G$: the classes of $\rho$ are the
cosets of some normal subgroup $N$.  The kernel of $\rho$ is defined as the set
of elements which are $\rho$-related to an idempotent.  Since there is only one
idempotent---the identity $1_G$---the kernel is all the elements in $N$.  The
trace of $\rho$ is defined as the restriction of $\rho$ to the idempotent; so
$\tr\rho$ is just the trivial equivalence on the single element $1_G$.  Hence a
congruence with normal subgroup $N$ has kernel-trace pair
$(N, \Delta_{\{1_G\}})$.

A group $G$ has precisely one Rees congruence: the universal congruence
$\rho_G$.  Its normal subgroup is the entire group $G$.

A completely 0-simple semigroup $\mathcal{M}^0[G;I,\Lambda;P]$ has two Rees
congruences: the universal congruence and the trivial congruence.  The universal
congruence has no linked triple, while the trivial congruence corresponds to the
linked triple $(\{1_G\}, \Delta_I, \Delta_\Lambda)$.  A completely simple
semigroup $\mathcal{M}[G;I,\Lambda;P]$ has only one Rees congruence: the
universal congruence, which has linked triple $(G, \nabla_I, \nabla_\Lambda)$.
% TODO: use nabla elsewhere instead of I x I or whatever

We may wish to convert between linked triples and kernel-trace pairs, in the
case of an inverse semigroup which is completely simple or completely 0-simple.
An inverse semigroup has exactly one idempotent in each $\LL$-class and each
$\RR$-class, and a simple semigroup is $\DD$-trivial with an idempotent in every
$\HH$-class.  Hence a completely simple inverse semigroup has just one $\HH$-class, and
since it contains an idempotent it must be a group.  Hence from above, and from
Section \ref{sec:normal-subgroup-to-linked-triple}, any congruence on a
completely simple inverse semigroup has a linked triple of the form
$(N, \Delta_I, \Delta_\Lambda)$ which corresponds to the kernel-trace pair
$(N, \Delta_{\{1_G\}})$.

A completely 0-simple inverse semigroup is somewhat different, but also
uncomplicated.  Let $S$ be such a semigroup, with idempotent set $E$.  Since
each $\LL$-class and each $\RR$-class has precisely one idempotent, the
relations $\varepsilon_I$ and $\varepsilon_\Lambda$ are both trivial, so the
non-universal congruences on $S$ correspond to triples of the form
$(N, \Delta_I, \Delta_\Lambda)$ for any normal subgroup $N \trianglelefteq G$.
Now, the triviality of $\Delta_I$ and $\Delta_\Lambda$ implies that no two
elements can be related by a congruence $\rho$ unless they lie inside the same
$\HH$-class.  Hence no two idempotents are related, so $\tr \rho = \Delta_E$.
The kernel consists of all elements in $S$ related to an idempotent.
Idempotents have the form $(i, 1_G, \lambda)$ where $p_{\lambda i} \neq 0$, so
the kernel is given by
$$\ker \rho = \{(i, n, \lambda) \in S ~|~ p_{\lambda i} \neq 0, n \in N\} \cup \{0\}.$$
TODO: explain how the $p_{\xi i}$ thing disappears because it's inverse.


\section{Things to add to this chapter}
\begin{enumerate}
\item Regular semigroups? (might not be the same sort of thing)
\item More sections to fill in conversions in Table \ref{tab:converting}
\end{enumerate}
