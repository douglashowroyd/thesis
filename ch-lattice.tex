\chapter{Finding a semigroup's congruence lattice}
\label{chap:lattice}

We can learn a lot about a semigroup's structure by examining its congruences:
they describe a semigroup's homomorphic images, and quotient semigroups, as
explained in Section \ref{sec:intro-congs}.  For this reason, it is of great
interest to be able to produce a complete list of congruences on a given
semigroup.

In group theory, we study normal subgroups instead of studying congruences
directly (see Section \ref{sec:normal-subgroups}).  Several algorithms exist for
computing a given group's normal subgroups, and therefore its congruences---see,
for example, \cite{hulpke_1998} for one of the methods used in GAP.  However,
since in the general case a semigroup's congruences are much less regular than
in the group case (for example, congruence classes may have different sizes) it
is certainly more computationally difficult to compute a complete list of
congruences for a given semigroup.

In this chapter, we present a method for calculating all the congruences of a
finite semigroup.  This algorithm takes advantage of the fact that congruences
lie in a lattice with respect to containment ($\subseteq$), intersection
($\cap$) and join ($\vee$).  It computes the lattice structure while it computes
the congruences themselves, and so the lattice structure is returned as an
output of the algorithm, along with the set of congruences.  This algorithm was
used as a starting point for the work described in Chapter \ref{chap:motzkin}.

In Section \ref{sec:lattice-algorithm} we give the algorithm in pseudo-code, and
explain how it works.  In Section \ref{sec:lattice-implementation} we outline
some practical concerns for implementing the algorithm, with particular
reference to how it is implemented in the Semigroups package \cite{semigroups}
for GAP \cite{gap}.  And finally, in Section \ref{sec:lattice-examples}, we
present some examples of lattices which have been computed using this algorithm.

\section{The algorithm}
\label{sec:lattice-algorithm}

For the purposes of this section, we will make the following definition.

\begin{definition}
  \label{def:congruence-poset}
  \index{congruence!poset}
  A \textbf{congruence poset} on a semigroup $S$ is a pair $(\Gamma, \PO)$
  where:
  \begin{itemize}
  \item $\Gamma$ is a set of congruences on $S$; and
  \item $\PO$ is $\subseteq$, the partial order of containment on $\Gamma$.
  \end{itemize}
\end{definition}

Recall that a partial order is defined as a relation that is reflexive
($x \leq x$), anti-symmetric ($x \leq y$ and $y \leq x$ if and only if $x = y$),
and transitive ($x \leq y$ and $y \leq z$ implies $x \leq z$).
\index{partial order}
Hence $\PO$ will be a set of pairs of the form $(\rho, \sigma)$, where $\rho$
and $\sigma$ are both congruences on $S$, and $\rho \subseteq \sigma$.  If
$\Gamma$ is the set of all congruences on $S$, then $(\Gamma, \PO)$ will be a
lattice by Theorem \ref{thm:congruence-lattice}, and two congruences $\rho$ and
$\sigma$ will have an intersection $\rho \cap \sigma$ and a join
$\rho \vee \sigma$ in $\Gamma$.

We first present an algorithm to calculate the principal congruences of a
semigroup, along with their partial ordering $\subseteq$.  This is a congruence
poset, but since it may not contain all the congruences on the given semigroup,
it may not be a lattice.  We call the algorithm \textsc{PrincCongPoset}, and we
give pseudo-code for it in Algorithm \ref{alg:princ-cong-poset}.

\begin{algorithm}
  \caption{The \textsc{PrincCongPoset} algorithm}
  \label{alg:princ-cong-poset}
  \index{PrincCongPoset@\textsc{PrincCongPoset}}
  \begin{algorithmic}[1]
    \Require $S$ a finite semigroup
    \Procedure{PrincCongPoset}{$S$}
      \State $\Gamma := \varnothing$
      \Comment{Set of congruences}
      \State $\PO := \varnothing$
      \Comment{Partial order ($\subseteq$) on congruences}
      \For{$(x,y) \in S \times S$}
        \State $P := \left\{\big((x,y)^\sharp, (x,y)^\sharp\big)\right\}$
        \Comment{Possible new pairs for $\PO$}
        \For{$(a,b)^\sharp \in \Gamma$}
          \If{$(x,y) \in (a,b)^\sharp$}
            \If{$(a,b) \in (x,y)^\sharp$}
              \State Skip to the next pair $(x,y)$
              \Comment{$(a,b)^\sharp = (x,y)^\sharp$}
            \Else
              \State $P \gets P \cup
                \left\{\big((x,y)^\sharp, (a,b)^\sharp\big)\right\}$
            \EndIf
          \ElsIf{$(a,b) \in (x,y)^\sharp$}
              \State $P \gets P \cup
                \left\{\big((a,b)^\sharp, (x,y)^\sharp\big)\right\}$
          \EndIf
        \EndFor
        \State $\Gamma \gets \Gamma \cup \{(x,y)^\sharp\}$
        \State $\PO \gets \PO \cup P$
        % \State Add $(x,y)^\sharp \leq (a,b)^\sharp$ for each $(a,b)^\sharp$ in $P$
        % \State Add $(a,b)^\sharp \leq (x,y)^\sharp$ for each $(a,b)^\sharp$ in $C$
        % \For{$(a,b)^\sharp \in P$}
        %   \State Set $(x,y)^\sharp \leq (a,b)^\sharp$
        % \EndFor
        % \For{$(a,b)^\sharp \in C$}
        %   \State Set $(a,b)^\sharp \leq (x,y)^\sharp$
        % \EndFor
        % \State $\PO \gets \PO \cup
        % \big\{\big((x,y)^\sharp, (a,b)^\sharp\big) : (a,b)^\sharp \in P\big\}$
        % \State $\PO \gets \PO \cup
        % \big\{\big((a,b)^\sharp, (x,y)^\sharp\big) : (a,b)^\sharp \in C\big\}$
      \EndFor
      \State \Return $(\Gamma, \PO)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

The idea of \textsc{PrincCongPoset} is to go through each pair in $S \times S$,
and consider the congruence generated by that pair.  We compare each new
congruence to the congruences we have found so far, establishing which of them
it contains, and which it is contained in.  If it turns out to be equal to a
congruence already found, we drop it immediately; if it turns out to be an
entirely new congruence, then we can add it to the list $\Gamma$ of congruences,
and add pairs to $\PO$ that describe how it compares to the other congruences.
Since each new congruence is compared to every previously found congruence,
every possible appropriate pair is added to $\PO$, and we are therefore
guaranteed that $\PO$ will be equal to the containment relation ($\subseteq$) by
the end of the algorithm.

One positive outcome of using generating pairs in this way is that we can use
the result
$$(a,b)^\sharp \subseteq (x,y)^\sharp \quad\iff\quad (a,b) \in (x,y)^\sharp$$
for any two pairs $(a,b), (x,y) \in S \times S$.  Hence, in order to compare the
two congruences comprehensively, we only need to test the presence of one pair
in each congruence: $(a,b) \in (x,y)^\sharp$ and $(x,y) \in (a,b)^\sharp$.
Testing the presence of a given pair in a congruence is likely to be faster
than, for example, exhaustively computing its congruence classes.  A general
algorithm for testing whether a given pair lies in a congruence specified by
generating pairs is described in Chapter \ref{chap:pairs}; in some cases this
can be improved by first converting the congruence to another representation, as
described in Chapter \ref{chap:converting}.

Our second algorithm is called \textsc{JoinClosure}.  This algorithm takes a
congruence poset $(\Gamma, \PO)$ as its argument, and returns the congruence
poset containing all the congruences in $\Gamma$ along with all their joins.
That is, for any collection of $k$ congruences
$(\rho_i)_{1 \leq i \leq k}$ from $\Gamma$, the output of
\textsc{JoinClosure} will contain the congruence
$$\bigvee_{1 \leq i \leq k} \rho_i
\quad=\quad \rho_1 \vee \rho_2 \vee \ldots \vee \rho_k.$$
Pseudo-code for \textsc{JoinClosure} is shown in Algorithm
\ref{alg:join-closure}.

\begin{algorithm}
  \caption{The \textsc{JoinClosure} algorithm}
  \label{alg:join-closure}
  \index{JoinClosure@\textsc{JoinClosure}}
  \begin{algorithmic}[1]
    \Require
    $S$ a finite semigroup,
    $(\Gamma,\PO)$ a congruence poset on $S$,
    all congruences in $\Gamma$ have generating pairs
    
    \Procedure{JoinClosure}{$(\Gamma,\PO)$}
      \State $\Gamma_I := \Gamma$ \Comment{Initial congruences}
      \State $\Gamma_N := \Gamma$ \Comment{New congruences (to be joined)}
      \While{$\Gamma_N \neq \varnothing$}
        \For{$\rho_N \in \Gamma_N$}
          \State $\Gamma_N \gets \Gamma_N \setminus \{\rho_N\}$
          \For{$\rho_I \in \Gamma_I$}
            \State $\rho := \rho_N \vee \rho_I$
            \State $P := \{(\rho, \rho)\}$
            \Comment{Possible new pairs for $\PO$}
            \For{$\sigma \in \Gamma$}
              \If{$\rho \subseteq \sigma$}
                \If{$\sigma \subseteq \rho$}
                  \State Skip to the next $\rho_I$
                  \Comment{$\rho = \sigma$}
                \Else
                  \State $P \gets P \cup \{(\rho, \sigma)\}$
                \EndIf
              \ElsIf{$\sigma \subseteq \rho$}
                \State $P \gets P \cup \{(\sigma, \rho)\}$
              \EndIf
            \EndFor
            \State $\Gamma \gets \Gamma \cup \{\rho\}$
            \State $\Gamma_N \gets \Gamma_N \cup \{\rho\}$
            \State $\PO \gets \PO \cup P$
          \EndFor
        \EndFor
      \EndWhile
      \State \Return $(\Gamma, \PO)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

The \textsc{JoinClosure} algorithm works by keeping a list $\Gamma_I$ of
``initial'' congruences (the ones we started with) and another list $\Gamma_N$
of congruences needing to be joined.  To start with, these are both equal to the
input $\Gamma$.  Each congruence in $\Gamma_N$ in turn is joined with each
initial congruence from $\Gamma_I$, and we check whether this join $\rho$ is a
new congruence or equal to one we have already found.  This check is done in a
similar way to \textsc{PrincCongPoset}, by checking $\rho \subseteq \sigma$ as
well as $\sigma \subseteq \rho$: if both are true, then we conclude that
$\rho = \sigma$ and therefore we don't have a new congruence; if just one is
true, we record the appropriate pair, and if $\rho$ is confirmed as a new
congruence, we add it to $\PO$ later.

In this algorithm, unlike in \textsc{PrincCongPoset}, we may encounter
congruences with more than one generating pair.  Hence, for two congruences
$\rho$ and $\sigma$, we cannot find out whether $\rho \subseteq \sigma$ in quite
the same way as we did in that algorithm.  We have one useful result: if
$\mathbf{R}$ and $\mathbf{S}$ are sets of generating pairs, then
$$\Rs \subseteq \mathbf{S}^\sharp \quad\iff\quad
\R \subseteq \mathbf{S}^\sharp,$$
so we only have to check containment of generating pairs in order to check
containment of congruences.  However, a congruence may have many generating
pairs, so in some cases this check may take a long time.  For this reason, if
there is an alternative way of representing the congruences (for example,
another representation from Chapter \ref{chap:converting}) then it may be
quicker to use a containment ($\subseteq$) method specific to that
representation.  For example, if $S$ is a 0-simple semigroup, then our two
congruences will have linked triples $(N_1,\sS_1,\tT_1)$ and $(N_2,\sS_2,\tT_2)$
respectively; instead of checking containment of generating pairs, we can check
whether $N_1 \leq N_2$, $\sS_1 \subseteq \sS_2$ and $\tT_1 \subseteq \tT_2$.

Each time we find a new congruence, we add it to $\Gamma_N$, and then later we
take its join with each initial congruence.  Hence, any congruence which can be
built up as the join of congruences in the initial list is eventually found.
For example, if there exists some congruence $\tau$ equal to
$\rho_1 \vee \rho_2 \vee \rho_3$, with $\rho_1,\rho_2,\rho_3 \in \Gamma_I$, then
we will find the congruence $\rho_1 \vee \rho_2$ on the first run of the while
loop, and it will be added to $\Gamma_N$.  Then, on the second run of the while
loop, we will compute $(\rho_1 \vee \rho_2) \vee \rho_3$, and hence we will find
$\tau$.  In this way, it is guaranteed that any join of congruences from
$\Gamma$ will appear in the output of
\textsc{JoinClosure}$((\Gamma, \PO))$

Now that we have described the two algorithms, it is easy to see how we can use
them to find the whole congruence lattice of a finite semigroup $S$.
\textsc{PrincCongPoset} finds all the principal congruences of $S$, and
\textsc{JoinClosure} finds all the joins of a set of congruences.  Since, in a
finite semigroup, any congruence is the join of a finite number of principal
congruences, we can produce the congruence lattice of $S$ by simply calling
$$\textsc{JoinClosure\big(PrincCongPoset($S$)\big)}.$$  This is the basis of the
function \texttt{LatticeOfCongruences} in the Semigroups package for GAP
\cite{semigroups}.

\section{Improvements}
\label{sec:lattice-improvements}

The \textsc{PrincCongPoset} algorithm as shown in Algorithm
\ref{alg:princ-cong-poset} is fairly simple, but can be modified in a few ways
to improve its performance.  Firstly, we should consider the source of
generating pairs: we iterate through all pairs $(x,y) \in S \times S$.  There
are ways in which this process is guaranteed to encounter a given congruence
twice, and therefore waste time.  For example, if we consider a pair $(x,y)$,
there is no need later to consider $(y,x)$, since it will generate the same
congruence.  Similarly there is no need to consider every reflexive pair
$(x,x)$, since each one is guaranteed to generate the trivial congruence.  Thus,
if $S$ has $n$ elements, we need only consider $\frac{1}{2}n(n-1)$ pairs, rather
than all $n^2$ pairs from $S \times S$.

Note that we could also replace $S$ here with some subset $X \subset S$, if we
wish to see what congruences can be generated only with pairs from $X \times X$.
For instance, we might be interested in congruences generated by pairs from some
ideal of $S$, and how they affect elements outside the ideal.  These questions
can be answered with minimal changes to the algorithm.

A possible improvement in both algorithms would be to use pairs already in
$\PO$, along with the axiom of transitivity, to skip certain comparisons.  For
example, if our new pair $(x,y)$ is found to be a subset of $(a,b)$, but $(a,b)$
is itself already known to be a subset of some congruence $(c,d)$, then we can
immediately add the pair $\big((x,y), (c,d)\big)$ to $P$ and we can skip the
comparison of $(x,y)$ to $(c,d)$ later in the algorithm.

Joining to known children/parents

\section{Implementation}
\label{sec:lattice-implementation}
\begin{itemize}
\item Children and Parents lists
\item Method selection for $\subseteq$
\end{itemize}

\section{Examples}
\label{sec:lattice-examples}
