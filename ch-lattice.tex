\chapter{Finding a semigroup's congruence lattice}
\label{chap:lattice}

We can learn a lot about a semigroup's structure by examining its congruences:
they describe a semigroup's homomorphic images, and quotient semigroups, as
explained in Section \ref{sec:intro-congs}.  For this reason, it is of great
interest to be able to produce a complete list of congruences on a given
semigroup.

In group theory, we study normal subgroups instead of studying congruences
directly (see Section \ref{sec:normal-subgroups}).  Several algorithms exist for
computing a given group's normal subgroups, and therefore its congruences---see,
for example, \cite{hulpke_1998} for one of the methods used in GAP.  However,
since in the general case a semigroup's congruences are much less regular than
in the group case (for example, congruence classes may have different sizes) it
is certainly more computationally difficult to compute a complete list of
congruences for a given semigroup.

In this chapter, we present a method for calculating all the congruences of a
finite semigroup.  This algorithm takes advantage of the fact that congruences
lie in a lattice with respect to containment ($\subseteq$), intersection
($\cap$) and join ($\vee$).  It computes the lattice structure while it computes
the congruences themselves, and so the lattice structure is returned as an
output of the algorithm, along with the set of congruences.  This algorithm was
used as a starting point for the work described in Chapter \ref{chap:motzkin}.

In Section \ref{sec:lattice-algorithm} we give the algorithm in pseudo-code, and
explain how it works.  Then in Section \ref{sec:lattice-complexity} we discuss
its complexity.  In Section \ref{sec:lattice-implementation} we outline some
practical concerns for implementing the algorithm, with particular reference to
how it is implemented in the Semigroups package \cite{semigroups} for GAP
\cite{gap}.  And finally, in Section \ref{sec:lattice-examples}, we present some
examples of lattices which have been computed using this algorithm.

\section{The algorithm}
\label{sec:lattice-algorithm}

For the purposes of this section, we will make the following definition.

\begin{definition}
  \label{def:congruence-poset}
  \index{congruence!poset}
  A \textbf{congruence poset} on a semigroup $S$ is a pair $(\Gamma, \PO)$
  where:
  \begin{itemize}
  \item $\Gamma$ is a set of congruences on $S$; and
  \item $\PO$ is $\subseteq$, the partial order of containment on $\Gamma$.
  \end{itemize}
\end{definition}

Recall that a partial order is defined as a relation that is reflexive
($x \leq x$), anti-symmetric ($x \leq y$ and $y \leq x$ if and only if $x = y$),
and transitive ($x \leq y$ and $y \leq z$ implies $x \leq z$).
\index{partial order}
Hence $\PO$ will be a set of pairs of the form $(\rho, \sigma)$, where $\rho$
and $\sigma$ are both congruences on $S$, and $\rho \subseteq \sigma$.  If
$\Gamma$ is the set of all congruences on $S$, then $(\Gamma, \PO)$ will be a
lattice by Theorem \ref{thm:congruence-lattice}, and two congruences $\rho$ and
$\sigma$ will have an intersection $\rho \cap \sigma$ and a join
$\rho \vee \sigma$ in $\Gamma$.

We first present an algorithm to calculate the principal congruences of a
semigroup, along with their partial ordering $\subseteq$.  This is a congruence
poset, but since it may not contain all the congruences on the given semigroup,
it may not be a lattice.  We call the algorithm \textsc{PrincCongPoset}, and we
give pseudo-code for it in Algorithm \ref{alg:princ-cong-poset}.

\begin{algorithm}
  \caption{The \textsc{PrincCongPoset} algorithm}
  \label{alg:princ-cong-poset}
  \index{PrincCongPoset@\textsc{PrincCongPoset}}
  \begin{algorithmic}[1]
    \Require $S$ a finite semigroup
    \Procedure{PrincCongPoset}{$S$}
      \State $\Gamma := \varnothing$
      \Comment{Set of congruences}
      \State $\PO := \varnothing$
      \Comment{Partial order ($\subseteq$) on congruences}
      \For{$(x,y) \in S \times S$}
        \State $P := \left\{\big((x,y)^\sharp, (x,y)^\sharp\big)\right\}$
        \Comment{Possible new pairs for $\PO$}
        \For{$(a,b)^\sharp \in \Gamma$}
          \If{$(x,y) \in (a,b)^\sharp$}
            \If{$(a,b) \in (x,y)^\sharp$}
              \State Skip to the next pair $(x,y)$
              \Comment{$(a,b)^\sharp = (x,y)^\sharp$}
            \Else
              \State $P \gets P \cup
                \left\{\big((x,y)^\sharp, (a,b)^\sharp\big)\right\}$
            \EndIf
          \ElsIf{$(a,b) \in (x,y)^\sharp$}
              \State $P \gets P \cup
                \left\{\big((a,b)^\sharp, (x,y)^\sharp\big)\right\}$
          \EndIf
        \EndFor
        \State $\Gamma \gets \Gamma \cup \{(x,y)^\sharp\}$
        \State $\PO \gets \PO \cup P$
        % \State Add $(x,y)^\sharp \leq (a,b)^\sharp$ for each $(a,b)^\sharp$ in $P$
        % \State Add $(a,b)^\sharp \leq (x,y)^\sharp$ for each $(a,b)^\sharp$ in $C$
        % \For{$(a,b)^\sharp \in P$}
        %   \State Set $(x,y)^\sharp \leq (a,b)^\sharp$
        % \EndFor
        % \For{$(a,b)^\sharp \in C$}
        %   \State Set $(a,b)^\sharp \leq (x,y)^\sharp$
        % \EndFor
        % \State $\PO \gets \PO \cup
        % \big\{\big((x,y)^\sharp, (a,b)^\sharp\big) : (a,b)^\sharp \in P\big\}$
        % \State $\PO \gets \PO \cup
        % \big\{\big((a,b)^\sharp, (x,y)^\sharp\big) : (a,b)^\sharp \in C\big\}$
      \EndFor
      \State \Return $(\Gamma, \PO)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

The idea of \textsc{PrincCongPoset} is to go through each pair in $S \times S$,
and consider the congruence generated by that pair.  We compare each new
congruence to the congruences we have found so far, establishing which of them
it contains, or is contained in.  If it is found to be equal to a congruence
already found, we drop it immediately; if it is found to be an entirely new
congruence, then we can add it to the list $\Gamma$ of congruences, and add
pairs to $\PO$ that describe how it compares to the other congruences.  Since
each new congruence is compared to every previously found congruence, every
possible appropriate pair is added to $\PO$, and we are therefore guaranteed
that $\PO$ will be equal to the containment relation ($\subseteq$) by the end of
the algorithm.

One positive outcome of using generating pairs in this way is that we can use
the result
$$(a,b)^\sharp \subseteq (x,y)^\sharp \quad\iff\quad (a,b) \in (x,y)^\sharp$$
for any two pairs $(a,b), (x,y) \in S \times S$.  Hence, in order to compare the
two congruences comprehensively, we only need to test the presence of one pair
in each congruence: $(a,b) \in (x,y)^\sharp$ and $(x,y) \in (a,b)^\sharp$.
Testing the presence of a given pair in a congruence is likely to be faster
than, for example, exhaustively computing its congruence classes.  A general
algorithm for testing whether a given pair lies in a congruence specified by
generating pairs is described in Chapter \ref{chap:pairs}; in some cases this
can be improved by first converting the congruence to another representation, as
described in Chapter \ref{chap:converting}.


\begin{algorithm}
  \caption{The \textsc{JoinClosure} algorithm}
  \label{alg:join-closure}
  \index{JoinClosure@\textsc{JoinClosure}}
  \begin{algorithmic}[1]
    \Require $S$ a finite semigroup, $(\Gamma,\PO)$ a poset of congruences on $S$
    \Procedure{JoinClosure}{$(\Gamma,\PO)$}
      \If{$|\Gamma| = 0$}
        \State \Return $(\Gamma, \PO)$
      \EndIf

      \State $\Gamma_N := \Gamma$ \Comment{New congruences (to be processed)}
      \State $\Gamma_I := \Gamma$ \Comment{Initial congruences}
      \While{$\Gamma_N \neq \varnothing$}
        \For{$\rho_N \in \Gamma_N$}
          \State $\Gamma_N \gets \Gamma_N \setminus \{\rho_N\}$
          \For{$\rho_I \in \Gamma_I$}
            \State $\rho := \rho_N \vee \rho_I$
            \State $P := \{(\rho, \rho)\}$
            \Comment{Possible new pairs for $\PO$}
            \For{$\sigma \in \Gamma$}
              \If{$\rho \subseteq \sigma$}
                \If{$\sigma \subseteq \rho$}
                  \State Skip to the next $\rho_I$
                  \Comment{$\rho = \sigma$}
                \Else
                  \State $P \gets P \cup \{(\rho, \sigma)\}$
                \EndIf
              \ElsIf{$\sigma \subseteq \rho$}
                \State $P \gets P \cup \{(\sigma, \rho)\}$
              \EndIf
            \EndFor
            \State $\Gamma \gets \Gamma \cup \{\rho\}$
            \State $\Gamma_N \gets \Gamma_N \cup \{\rho\}$
            \State $\PO \gets \PO \cup P$
          \EndFor
        \EndFor
      \EndWhile
      \State \Return $(\Gamma, \PO)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\section{Improvements}
\label{sec:lattice-improvements}

The \textsc{PrincCongPoset} algorithm as shown in Algorithm
\ref{alg:princ-cong-poset} is fairly simple, but can be modified in a few ways
to improve its performance.  Firstly, we should consider the source of
generating pairs: we iterate through all pairs $(x,y) \in S \times S$.  There
are ways in which this process is guaranteed to encounter a given congruence
twice, and therefore waste time.  For example, if we consider a pair $(x,y)$,
there is no need later to consider $(y,x)$, since it will generate the same
congruence.  Similarly there is no need to consider every reflexive pair
$(x,x)$, since each one is guaranteed to generate the trivial congruence.  Thus,
if $S$ has $n$ elements, we need only consider $\frac{1}{2}n(n-1)$ pairs, rather
than all $n^2$ pairs from $S \times S$.

Note that we could also replace $S$ here with some subset $X \subset S$, if we
wish to see what congruences can be generated only with pairs from $X \times X$.
For instance, we might be interested in congruences generated by pairs from some
ideal of $S$, and how they affect elements outside the ideal.  These questions
can be answered with minimal changes to the algorithm.

Another possible improvement could be to use pairs already in $\PO$, along with
the axiom of transitivity, to skip certain comparisons.  For example, if our new
pair $(x,y)$ is found to be a subset of $(a,b)$, but $(a,b)$ is itself already
known to be a subset of some congruence $(c,d)$, then we can immediately add the
pair $\big((x,y), (c,d)\big)$ to $P$ and we can skip the comparison of $(x,y)$
to $(c,d)$ later in the algorithm.

\section{Complexity}
\label{sec:lattice-complexity}

\section{Implementation}
\label{sec:lattice-implementation}

\section{Examples}
\label{sec:lattice-examples}
