\chapter{Finding a semigroup's congruence lattice}
\label{chap:lattice}

We can learn a lot about a semigroup's structure by examining its congruences:
they describe a semigroup's homomorphic images, and quotient semigroups, as
explained in Section \ref{sec:intro-congs}.  For this reason, it is of great
interest to be able to produce a complete list of congruences on a given
semigroup.

In group theory, we study normal subgroups instead of studying congruences
directly (see Section \ref{sec:normal-subgroups}).  Several algorithms exist for
computing a given group's normal subgroups, and therefore its congruences---see,
for example, \cite{hulpke_1998} for one of the methods used in GAP.  However,
since in the general case a semigroup's congruences are much less regular than
in the group case (for example, congruence classes may have different sizes) it
is certainly more computationally difficult to compute a complete list of
congruences for a given semigroup.

In this chapter, we present a method for calculating all the congruences of a
finite semigroup.  This algorithm takes advantage of the fact that congruences
lie in a lattice with respect to containment ($\subseteq$), intersection
($\cap$) and join ($\vee$).  The congruences are therefore computed in this
lattice, and so the lattice structure is returned along with the set of
congruences, as an output of the algorithm.  This algorithm was used as a
starting point for the work described in Chapter \ref{chap:motzkin}.

In Section \ref{sec:lattice-algorithm} we give the algorithm in pseudo-code, and
explain how it works.  Then, in Section \ref{sec:lattice-complexity} we discuss
its complexity.  In Section \ref{sec:lattice-implementation} we outline some
practical concerns for implementing the algorithm, with particular reference to
how it is implemented in the Semigroups package \cite{semigroups} for GAP
\cite{gap}.  And finally, in Section \ref{sec:lattice-examples}, we present some
examples of lattices which have been computed using this algorithm.

\section{The algorithm}
\label{sec:lattice-algorithm}

\begin{algorithm}
  \caption{The \textsc{PrincCongPoset} algorithm}
  \label{alg:princ-cong-poset}
  \index{PrincCongPoset@\textsc{PrincCongPoset}}
  \begin{algorithmic}[1]
    \Require $S$ a finite semigroup
    \Procedure{PrincCongPoset}{$S$}
      \State $\Gamma := \varnothing$
      \Comment{Set of congruences}
      \State $\PO := \varnothing$
      \Comment{Partial order ($\subseteq$) on congruences}
      \For{$(x,y) \in S \times S$}
        \State $P := \left\{\big((x,y)^\sharp, (x,y)^\sharp\big)\right\}$
        \Comment{Possible new pairs for $\PO$}
        \For{$(a,b)^\sharp \in \Gamma$}
          \If{$(x,y) \in (a,b)^\sharp$}
            \If{$(a,b) \in (x,y)^\sharp$}
              \State Skip to the next pair $(x,y)$
              \Comment{$(a,b)^\sharp = (x,y)^\sharp$}
            \Else
              \State $P \gets P \cup
                \left\{\big((x,y)^\sharp, (a,b)^\sharp\big)\right\}$
            \EndIf
          \ElsIf{$(a,b) \in (x,y)^\sharp$}
              \State $P \gets P \cup
                \left\{\big((a,b)^\sharp, (x,y)^\sharp\big)\right\}$
          \EndIf
        \EndFor
        \State $\Gamma \gets \Gamma \cup \{(x,y)^\sharp\}$
        \State $\PO \gets \PO \cup P$
        % \State Add $(x,y)^\sharp \leq (a,b)^\sharp$ for each $(a,b)^\sharp$ in $P$
        % \State Add $(a,b)^\sharp \leq (x,y)^\sharp$ for each $(a,b)^\sharp$ in $C$
        % \For{$(a,b)^\sharp \in P$}
        %   \State Set $(x,y)^\sharp \leq (a,b)^\sharp$
        % \EndFor
        % \For{$(a,b)^\sharp \in C$}
        %   \State Set $(a,b)^\sharp \leq (x,y)^\sharp$
        % \EndFor
        % \State $\PO \gets \PO \cup
        % \big\{\big((x,y)^\sharp, (a,b)^\sharp\big) : (a,b)^\sharp \in P\big\}$
        % \State $\PO \gets \PO \cup
        % \big\{\big((a,b)^\sharp, (x,y)^\sharp\big) : (a,b)^\sharp \in C\big\}$
      \EndFor
      \State \Return $(\Gamma, \PO)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

May use a subset of $S \times S$ to analyse congruences generated by a
``restriction''.

\begin{algorithm}
  \caption{The \textsc{JoinClosure} algorithm}
  \label{alg:join-closure}
  \index{JoinClosure@\textsc{JoinClosure}}
  \begin{algorithmic}[1]
    \Require $S$ a finite semigroup, $(\Gamma,\PO)$ a poset of congruences on $S$
    \Procedure{JoinClosure}{$(\Gamma,\PO)$}
      \If{$|\Gamma| = 0$}
        \State \Return $(\Gamma, \PO)$
      \EndIf

      \State $\Gamma_N := \Gamma$ \Comment{New congruences (to be processed)}
      \State $\Gamma_I := \Gamma$ \Comment{Initial congruences}
      \While{$\Gamma_N \neq \varnothing$}
        \For{$\rho_N \in \Gamma_N$}
          \State $\Gamma_N \gets \Gamma_N \setminus \{\rho_N\}$
          \For{$\rho_I \in \Gamma_I$}
            \State $\rho := \rho_N \vee \rho_I$
            \State $P := \{(\rho, \rho)\}$
            \Comment{Possible new pairs for $\PO$}
            \For{$\sigma \in \Gamma$}
              \If{$\rho \subseteq \sigma$}
                \If{$\sigma \subseteq \rho$}
                  \State Skip to the next $\rho_I$
                  \Comment{$\rho = \sigma$}
                \Else
                  \State $P \gets P \cup \{(\rho, \sigma)\}$
                \EndIf
              \ElsIf{$\sigma \subseteq \rho$}
                \State $P \gets P \cup \{(\sigma, \rho)\}$
              \EndIf
            \EndFor
            \State $\Gamma \gets \Gamma \cup \{\rho\}$
            \State $\Gamma_N \gets \Gamma_N \cup \{\rho\}$
            \State $\PO \gets \PO \cup P$
          \EndFor
        \EndFor
      \EndWhile
      \State \Return $(\Gamma, \PO)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\section{Complexity}
\label{sec:lattice-complexity}

\section{Implementation}
\label{sec:lattice-implementation}

\section{Examples}
\label{sec:lattice-examples}
